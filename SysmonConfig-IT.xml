<!--                               NOTICE: This Sysmon configuration rule has been designed to monitor and detect activities associated with APTs targeting IT companies.                              -->
<!--                                       It has been carefully crafted to provide comprehensive coverage of known APT tactics, techniques, and procedures commonly                                   -->
<!--                                       observed in such attacks.                                                                                                                                   -->
<!--      ___________                                                                                                                                                                                  -->    
<!--     /###########\                     While this rule aims to enhance our detection capabilities and bolster our security posture against APTs, it's important to                                 -->  
<!--    /#############\                    acknowledge that no rule or detection mechanism can provide absolute coverage. Despite our best efforts, there may exist certain blind                      --> 
<!--   |###  _***_  ###|                   spots or evasion techniques that could potentially evade detection by this rule.                                                                            -->
<!--   |### /  B  \ ###|                                                                                                                                                                               -->
<!--   |### \  L  / ###|                                 _______                                                                                                                                       -->   
<!--   |###  \_U_/  ###|                                / _____/_  ____________  __  ____  _____                                                                                                       -->   
<!--    \#############/                                 \__ \ / / / / ____/ __  __ \/ __ \/ ___ \                                                                                                      -->
<!--      \#########/                                   ___/ / /_/ (___  ) / / / / / /_/ / /  / /                                                                                                      -->
<!--        \#####/                                   /_____/ \__, /____/_/ /_/ /_/\____/_/  /_/                                                                                                       -->
<!--                                                         /____/                                       by sudous3r                                                                                  -->

<!--
    Sysmon-Config | A Sysmon configuration repository, designed specifically for IT companies and organizations seeking to optimize their log monitoring practices.
    Created: 23-August-2024
    Source project: https://github.com/sudous3r/SysmonConfig
    
    NOTE: This Sysmon configuration provided herein is designed with high verbosity to capture a wide 
          range of system activity. However, Every company operates within a unique technological ecosystem, 
          utilizing different software applications, configurations, and network architectures. 
          As such, it is imperative to understand that the provided configuration serves as a starting point 
          and may require modifications to align with the specific needs and nuances of individual environments.
                                                                                                               -->

<Sysmon schemaversion="4.90">

        <HashAlgorithms>md5,sha256,IMPHASH</HashAlgorithms>
        <CheckRevocation/>

        <EventFiltering>

<!-- Data: RuleName, UtcTime, ProcessGuid, ProcessID, Image, FileVersion, Description, Product, Company, OriginalFileName, CommandLine, CurrentDirectory, User, LogonGuid, LogonId, TerminalSessionId, IntegrityLevel, Hashes, ParentProcessGuid, ParentProcessId, ParentImage, ParentCommandLine, ParentUser -->
<!-- EVENT ID 1 : PROCESS CREATION [ProcessCreate]-->

               <RuleGroup groupRelation="or">
                   <ProcessCreate onmatch="include">

                     <Rule name="T1133, External Remote Services (Running Chrome VPN Extensions via the Registry 2 vpn extension)" groupRelation="and">                     <!-- Running Chrome VPN Extensions via the Registry install 2 vpn extension. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">HKLM:\Software\Wow6432Node\Google\Chrome\Extensions\$extension</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059, Command and Scripting Interpreter (AutoIt Script Execution)" groupRelation="and">                                                   <!-- An adversary may attempt to execute suspicious or malicious script using AutoIt software instead of regular terminal like powershell or cmd. Calculator will popup when the script is executed successfully. -->
                         <OriginalFileName condition="is">Powershell.EXE</OriginalFileName>
                         <CommandLine condition="contains">AutoIt3.exe</CommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (Run BloodHound from local disk)" groupRelation="and">             <!-- Upon execution SharpHound will be downloaded to disk, imported and executed. It will set up collection methods, run and then compress and store the data to the temp directory on the machine. If system is unable to contact a domain, proper execution will not occur. Successful execution will produce stdout message stating "SharpHound Enumeration Completed". Upon completion, final output will be a *BloodHound.zip file. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-BloodHound</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (Mimikatz - Cradlecraft PsSendKeys)" groupRelation="and">          <!-- Run mimikatz via PsSendKeys. Upon execution, automated actions will take place to open file explorer, open notepad and input code, then mimikatz dump info will be displayed. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-Mimikatz -DumpCreds</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (Invoke-AppPathBypass)" groupRelation="and">                       <!-- Note: Windows 10 only. Upon execution windows backup and restore window will be opened. Bypass is based on: https://enigma0x3.net/2017/03/14/bypassing-uac-using-app-paths/ -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-AppPathBypass</ParentCommandLine>
                     </Rule>
                     
                     <Rule name="T1059-001, Command and Scripting Interpreter (Powershell MsXml COM object - with prompt)" groupRelation="and">                       <!-- Powershell MsXml COM object. Not proxy aware, removing cache although does not appear to write to those locations. Provided by https://github.com/mgreen27/mgreen27.github.io -->
                         <Image condition="contains">PowerShell.EXE</Image>
                         <CommandLine condition="contains">-ComObject</CommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (Powershell XML requests)" groupRelation="and">                       <!-- Powershell xml download request. Provided by https://github.com/mgreen27/mgreen27.github.io -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">Xml.Load</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (Powershell invoke mshta.exe download)" groupRelation="and">          <!-- Powershell invoke mshta to download payload.Provided by https://github.com/mgreen27/mgreen27.github.io -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">mshta.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (NTFS Alternate Data Stream Access)" groupRelation="and">             <!-- Creates a file with an alternate data stream and simulates executing that hidden code/file. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">streamCommand</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Session Creation and Use)" groupRelation="and">           <!-- Connect to a remote powershell session and interact with the host. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">New-PSSession -ComputerName</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (ATHPowerShellCommandLineParameter -Command parameter variations)" groupRelation="and">           <!-- Executes powershell.exe with variations of the -Command parameter. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">-CommandParamVariation</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (ATHPowerShellCommandLineParameter -Command parameter variations with encoded arguments)" groupRelation="and">           <!-- Executes powershell.exe with variations of the -Command parameter with encoded arguments supplied. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">-CommandParamVariation;-UseEncodedArguments</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (ATHPowerShellCommandLineParameter -EncodedCommand parameter variations)" groupRelation="and">           <!-- Executes powershell.exe with variations of the -EncodedCommand parameter. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">-EncodedCommandParamVariation</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Add-Persistence</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Find-AVSignature</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Get-GPPAutologon</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Get-GPPPassword</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Get-HttpStatus</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Get-Keystrokes</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Get-SecurityPackages</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Get-TimedScreenshot</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Get-VaultCredential</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Get-VolumeShadowCopy</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Install-SSP</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-CredentialInjection</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-DllInjection</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-Mimikatz</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-NinjaCopy</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-Portscan</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-ReflectivePEInjection</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-ReverseDnsLookup</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-Shellcode</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-TokenManipulation</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-WmiCommand</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Mount-VolumeShadowCopy</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">New-ElevatedPersistenceOption</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">New-UserPersistenceOption</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">New-VolumeShadowCopy</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Out-CompressedDll</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Out-EncodedCommand</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Out-EncryptedScript</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Out-Minidump</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">PowerUp</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">PowerView</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Remove-Comments</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Remove-VolumeShadowCopy</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Set-CriticalProcess</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerShell Invoke Known Malicious Cmdlets)" groupRelation="and">           <!-- Powershell execution of known Malicious PowerShell Cmdlets. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Set-MasterBootRecord</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (PowerUp Invoke-AllChecks)" groupRelation="and">           <!-- Check for privilege escalation paths using PowerUp from PowerShellMafia. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-AllChecks</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (Abuse Nslookup with DNS Records)" groupRelation="and">           <!-- Red teamer's avoid IEX and Invoke-WebRequest in your PowerShell commands. Instead, host a text record with a payload to compromise hosts. [reference](https://twitter.com/jstrosch/status/1237382986557001729) -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">function nslookup</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-001, Command and Scripting Interpreter (SOAPHound - Dump BloodHound Data)" groupRelation="and">           <!-- Dump BloodHound data using SOAPHound. Upon execution, BloodHound data will be dumped and stored in the specified output directory. src: https://github.com/FalconForceTeam/SOAPHound -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">SOAPHound.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-005, Command and Scripting Interpreter (Visual Basic script execution to gather local computer information)" groupRelation="and">           <!-- Visual Basic execution. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">cscript</ParentCommandLine>
                     </Rule>

                     <Rule name="T1059-005, Command and Scripting Interpreter (JScript execution to gather local computer information via wscript)" groupRelation="and">           <!-- JScript execution, execute JScript via wscript command. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">wscript</ParentCommandLine>
                     </Rule>

                     <Rule name="T1098, Account Manipulation (Admin Account Manipulate)" groupRelation="and">                                                                   <!-- Manipulate Admin Account Name --> 
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Get-LocalGroupMember -Group Administrators</CommandLine>
                     </Rule>

                     <Rule name="T1098, Account Manipulation (Admin Account Manipulate)" groupRelation="and">                                                                   <!-- Create a random atr-nnnnnnnn account and add it to a domain group (by default, Domain Admins). --> 
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Import-Module ActiveDirectory</CommandLine>
                     </Rule>  

                     <Rule name="T1098, Account Manipulation (Admin Account Manipulate)" groupRelation="and">                                                                   <!-- The adversaries want to add user to some Azure AD role. Threat actor  may be interested primarily in highly privileged roles, e.g. Global Administrator, Application Administrator,  Privileged Authentication Administrator (this role can reset Global Administrator password!). By default, the role Global Reader is assigned to the user principal. The account you use to run the PowerShell command should have Privileged Role Administrator or Global Administrator role in your Azure AD. Detection hint - check Activity "Add member to role" in Azure AD Audit Logs. In targer you will also see User as a type. --> 
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Import-Module -Name AzureAD</CommandLine>
                     </Rule>

                     <Rule name="T1098, Account Manipulation (Azure - adding user, service, permission to application to Azure role in subscription)" groupRelation="and">                                          <!-- The adversaries want to add user to some Azure role, also called Azure resource role. Threat actor  may be interested primarily in highly privileged roles, e.g. Owner, Contributor. By default, the role Reader is assigned to user. --> 
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Import-Module -Name Az.Resources</CommandLine>
                     </Rule>

                     <Rule name="T1098, Account Manipulation (Password Change on Directory Service Restore Mode (DSRM) Account)" groupRelation="and">                               <!-- Change the password on the Directory Service Restore Mode (DSRM) account using ntdsutil by syncing to existing account. -->    
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">"ntdsutil set dsrm password"</CommandLine>
                     </Rule>

                     <Rule name="T1098, Account Manipulation (Domain Password Policy Check)" groupRelation="and">                                                   <!-- Attempt to change the password of the current domain user in order to check password policy. -->    
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">System.Management.Automation.PSCredential</CommandLine>
                     </Rule>

                     <Rule name="T1098, Account Manipulation (EXO - Full access mailbox permission granted to a user)" groupRelation="and">                         <!-- Give a nominated user, full mailbox delegation access of another user. This can be used by an adversary to maintain persistent access to a target's mailbox in M365. -->    
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Import-Module ExchangeOnlineManagement</CommandLine>
                     </Rule>

                     <Rule name="T1098, Account Manipulation (Simulate - Post BEC persistence via user password reset followed by user added to company administrator role)" groupRelation="and">                         <!-- It involves resetting the password of a normal user and adding to the company administrator role within M365.  Reference: https://www.huntress.com/blog/business-email-compromise-via-azure-administrative-privileges -->    
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Import-Module MSOnline</CommandLine>
                     </Rule>

                     <Rule name="T1098-001, Account Manipulation: Additional Cloud (Azure AD Application Hijacking)" groupRelation="and">                         <!-- Add a certificate to an Application through its Service Principal. The certificate can then be used to authenticate as the application. This can be used for persistence, and also for privilege escalation by benefiting from the Application's rights. An account with high-enough Azure AD privileges is needed, such as Global Administrator or Application Administrator. The account authentication must be without MFA. -->    
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Import-Module -Name AzureAD</ParentCommandLine>
                     </Rule>

                     <Rule name="T1098-002, Account Manipulation: Additional Email Delegate Permissions (EXO - Full access mailbox permission granted to a user)" groupRelation="and">                         <!-- Give a nominated user, full mailbox delegation access of another user. This can be used by an adversary to maintain persistent access to a target's mailbox in M365. -->    
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Import-Module ExchangeOnlineManagement</ParentCommandLine>
                     </Rule>

                     <Rule name="T1098-003, Account Manipulation: Additional Cloud Roles (Azure AD - Add Company Administrator Role to a user)" groupRelation="and">                         <!-- Add an existing Azure user account the Company Administrator Role. -->    
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Import-Module MSOnline</ParentCommandLine>
                     </Rule>

                     <Rule name="T1197, BITS Jobs (Bitsadmin Download (cmd))" groupRelation="and">                            <!-- This test simulates an adversary leveraging bitsadmin.exe to download and execute a payload. -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">bitsadmin.exe /transfer /Download</ParentCommandLine>
                     </Rule>

                     <Rule name="T1197, BITS Jobs (Bitsadmin Download (PowerShell))" groupRelation="and">                            <!-- This test simulates an adversary leveraging bitsadmin.exe to download and execute a payload leveraging PowerShell. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Start-BitsTransfer -Priority</ParentCommandLine>
                     </Rule>

                     <Rule name="T1197, BITS Jobs (Persist, Download, and Execute)" groupRelation="and">                            <!--  an adversary leveraging bitsadmin.exe to schedule a BITS transferand execute a payload in multiple steps. -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">bitsadmin.exe;/creat;/addfile;/resume;/complete</ParentCommandLine>
                     </Rule>

                     <Rule name="T1197, BITS Jobs (Bits download using desktopimgdownldr.exe (cmd))" groupRelation="and">                            <!-- simulates using desktopimgdownldr.exe to download a malicious file instead of a desktop or lockscreen background img. The process that actually makes  the TCP connection and creates the file on the disk is a svchost process (â€œ-k netsvc -p -s BITSâ€)  and not desktopimgdownldr.exe. See https://labs.sentinelone.com/living-off-windows-land-a-new-native-file-downldr/ -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">desktopimgdownldr.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1037-001, Boot or Logon Initialization Scripts: Logon Script (Logon Scripts)" groupRelation="and">                            <!-- Adds a registry value to run batch script created in the %temp% directory. Upon execution, there will be a new environment variable in the HKCU\Environment key that can be viewed in the Registry Editor. -->
                         <Image condition="contains">reg.exe</Image>
                         <CommandLine condition="contains">REG.exe ADD HKCU\Environment</CommandLine>
                     </Rule>

                     <Rule name="T1136-002, Create Account: Domain Account (Create a new Domain Account using PowerShell)" groupRelation="and">                            <!-- Creates a new Domain User using the credentials of the Current User. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">$SamAccountName</ParentCommandLine>
                     </Rule>

                     <Rule name="T1136-003, Create Account: Cloud Account (Azure AD - Create a new user)" groupRelation="and">                            <!-- Creates a new user in Azure AD. Upon successful creation, a new user will be created. Adversaries create new users so that their malicious activity does not interrupt the normal functions of the compromised users and can remain undetected for a long time. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">$userprincipalname</ParentCommandLine>
                     </Rule>

                     <Rule name="T1133, External Remote Services (Running Chrome VPN Extensions via the Registry 2 vpn extension)" groupRelation="and">                     <!-- Running Chrome VPN Extensions via the Registry install 2 vpn extension. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">HKLM:\Software\Wow6432Node\Google\Chrome\Extensions\$extension</ParentCommandLine>
                     </Rule>

                     <Rule name="T1574-001, Hijack Execution Flow: DLL Search Order Hijacking (DLL Search Order Hijacking - amsi.dll)" groupRelation="and">                 <!-- Adversaries can take advantage of insecure library loading by PowerShell to load a vulnerable version of amsi.dll in order to bypass AMSI (Anti-Malware Scanning Interface) https://enigma0x3.net/2017/07/19/bypassing-amsi-via-com-server-hijacking/ -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">amsi.dll</ParentCommandLine>
                     </Rule>

                     <Rule name="T1574-001, Hijack Execution Flow: DLL Side-Loading (DLL Side-Loading using the Notepad++ GUP.exe binary)" groupRelation="and">                     <!-- GUP is an open source signed binary used by Notepad++ for software updates, and is vulnerable to DLL Side-Loading, thus enabling the libcurl dll to be loaded. -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">GUP.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1574-002, Hijack Execution Flow: DLL Side-Loading (DLL Side-Loading using the dotnet startup hook environment variable)" groupRelation="and">                     <!-- Utilizing the dotnet_startup_hooks environment variable, this method allows for registering a global method in an assembly that will be executed whenever a .net core application is started. This unlocks a whole range of scenarios, from injecting a profiler to tweaking a static context in a given environment. [blog post](https://medium.com/criteo-engineering/c-have-some-fun-with-net-core-startup-hooks-498b9ad001e1) -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">set DOTNET</ParentCommandLine>
                     </Rule>

                     <Rule name="T1574-008, Hijack Execution Flow: Path Interception by Search Order Hijacking (powerShell Persistence via hijacking default modules - Get-Variable.exe)" groupRelation="and">                     <!-- Colibri leverages PowerShell in a unique way to maintain persistence after a reboot. Depending on the Windows version, Colibri drops its copy in %APPDATA%\Local\Microsoft\WindowsApps and  names it Get-Variable.exe for Windows 10 and above. https://blog.malwarebytes.com/threat-intelligence/2022/04/colibri-loader-combines-task-scheduler-and-powershell-in-clever-persistence-technique/ -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <CommandLine condition="contains">Get-Variable.exe</CommandLine>
                     </Rule>

                     <Rule name="T1574-009, Hijack Execution Flow: Path Interception by Unquoted Path (Execution of program.exe as service with unquoted service path)" groupRelation="and">                     <!--  When a service is created whose executable path contains spaces and isnâ€™t enclosed within quotes, leads to a vulnerability known as Unquoted Service Path which allows a user to gain SYSTEM privileges. In this case, if an executable program.exe in C:\ exists, C:\program.exe will be executed instead of test.exe in C:\Program Files\subfolder\test.exe. -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">program.exe;test.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1078-001, Valid Accounts: Default Accounts (Enable Guest account with RDP capability and admin privileges)" groupRelation="and">          <!-- After execution the Default Guest account will be enabled (Active) and added to Administrators and Remote Desktop Users Group, and desktop will allow multiple RDP connections. -->    
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">net user</ParentCommandLine>
                     </Rule> 

                     <Rule name="T1078-001, Valid Accounts: Default Accounts (Enable Guest account with RDP capability and admin privileges)" groupRelation="and">          <!-- After execution the Default Guest account will be enabled (Active) and added to Administrators and Remote Desktop Users Group, and desktop will allow multiple RDP connections. -->    
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">net localgroup</ParentCommandLine>
                     </Rule>   

                     <Rule name="T1078-003, Valid Accounts: Local Accounts (WinPwn - Loot local Credentials)" groupRelation="and">                                          <!-- Loot local Credentials via function WinPwn -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">safedump -consoleoutput -noninteractive</ParentCommandLine>
                     </Rule>

                     <Rule name="T1078-004, Valid Accounts: Cloud Accounts (Azure Persistence Automation Runbook Created or Modified)" groupRelation="and">                 <!-- Identifies when an Azure Automation runbook is created or modified. An adversary may create or modify an Azure Automation runbook to execute malicious code and maintain persistence in their target's environment. -->
                         <OriginalFileName condition="is">Powershell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Connect-AzAccount</CommandLine>
                     </Rule>

                     <Rule name="T1078-004, Valid Accounts: Cloud Accounts (Azure Persistence Automation Runbook Created or Modified)" groupRelation="and">         <!-- Identifies when an Azure Automation runbook is created or modified. An adversary may create or modify an Azure Automation runbook to execute malicious code and maintain persistence in their target's environment. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">New-AzAutomationRunbook</ParentCommandLine>
                     </Rule>

                     <Rule name="T1134-001, Access Token Manipulation: Token Impersonation/Theft (Named pipe client impersonation)" groupRelation="and">                    <!-- Uses PowerShell and Empire's [GetSystem module](https://github.com/BC-SECURITY/Empire/blob/v3.4.0/data/module_source/privesc/Get-System.ps1). The script creates a named pipe, and a service that writes to that named pipe. When the service connects to the named pipe, the script impersonates its security context. Reference: https://blog.cobaltstrike.com/2014/04/02/what-happens-when-i-type-getsystem/ -->  
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Get-System -Technique NamedPipe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1134-001, Access Token Manipulation: Token Impersonation/Theft (`SeDebugPrivilege` token duplication)" groupRelation="and">               <!-- Uses PowerShell and Empire's [GetSystem module](https://github.com/BC-SECURITY/Empire/blob/v3.4.0/data/module_source/privesc/Get-System.ps1). The script uses `SeDebugPrivilege` to obtain, duplicate and impersonate the token of a another process. -->  
                         <OriginalFileName condition="contains">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Get-System -Technique Token</CommandLine>
                     </Rule>

                     <Rule name="T1134-001, Access Token Manipulation: Token Impersonation/Theft (Launch NSudo Executable)" groupRelation="and">                    <!-- Launches the NSudo executable for a short period of time and then exits. NSudo download observed after maldoc execution. NSudo is a system management tool for advanced users to launch programs with full privileges. -->  
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">NSudoLG.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1134-001, Access Token Manipulation: Token Impersonation/Theft (Bad Potato)" groupRelation="and">                                         <!-- https://github.com/BeichenDream/BadPotato Privilege escalation using named pipe connections. -->                 
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">BadPotato.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1134-001, Access Token Manipulation: Token Impersonation/Theft (Juicy Potato)" groupRelation="and">                                       <!-- A vulnerable CLSID will be used to execute a process with system permissions. This tactic has been previously observed in SnapMC Ransomware, amongst numerous other campaigns.  [Reference](https://blog.fox-it.com/2021/10/11/snapmc-skips-ransomware-steals-data/) -->                 
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">JuicyPotato.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1134-002, Create Process with Token (Access Token Manipulation)" groupRelation="and">                                                     <!-- Access token for a specific program can spawn another program under a different owner.  Adversaries can leverage access tokens to run programs under a different user not only to achieve privilege escalation but also to evade detection by blending in with normal user activity.  This Action will query all processes and list the process name and owner.It will then make a copy of an existing token to create a new instance of cmd.exe. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Set-ExecutionPolicy -Scope Process Bypass -Force</ParentCommandLine>
                     </Rule>

                      <Rule name="T1134-002, Create Process with Token (WinPwn - Get SYSTEM shell - Pop System Shell using Token Manipulation technique)" groupRelation="and">                                                     <!-- Get SYSTEM shell - Pop System Shell using Token Manipulation technique via function of WinPwn. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Get-WinLogonTokenSystem</ParentCommandLine>
                     </Rule>   

                     <Rule name="T1134-004, Access Token Manipulation: Parent PID Spoofing (Parent PID Spoofing using PowerShell)" groupRelation="and">                    <!-- PowerShell to replicates how Cobalt Strike does ppid spoofing and masquerade a spawned process. Credit to In Ming Loh (https://github.com/countercept/ppid-spoofing/blob/master/PPID-Spoof.ps1) -->                           
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">$ppid=Get-Process</ParentCommandLine>
                     </Rule>

                     <Rule name="T1134-004, Access Token Manipulation: Parent PID Spoofing (Parent PID Spoofing - Spawn from Current Process)" groupRelation="and">                    <!-- Spawns a powershell.exe process as a child of the current process. -->                           
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">Start-ATHProcessUnderSpecificParent; -ParentId</ParentCommandLine>
                     </Rule>                   

                     <Rule name="T1134-004, Access Token Manipulation: Parent PID Spoofing (Parent PID Spoofing - Spawn from svchost.exe)" groupRelation="and">                    <!-- Spawns a process as a child of the first accessible svchost.exe process. -->                           
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">Get-CimInstance; Win32_Process</ParentCommandLine>
                     </Rule>

                     <Rule name="T1134-004, Access Token Manipulation: Parent PID Spoofing (Parent PID Spoofing - Spawn from New Process)" groupRelation="and">                    <!-- Creates a notepad.exe process and then spawns a powershell.exe process as a child of it. -->                           
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">Start-Process; Start-ATHProcessUnderSpecificParent</ParentCommandLine>
                     </Rule>

                     <Rule name="T1134-005, Access Token Manipulation: SID-History Injection (Injection SID-History with mimikatz)" groupRelation="and">                           <!-- Adversaries may use SID-History Injection to escalate privileges and bypass access controls. Must be run on domain controller. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains all">privilege::debug; sid::patch</CommandLine>
                     </Rule>

                     <Rule name="T1055, Process Injection (Remote Process Injection in LSASS via mimikatz)" groupRelation="and">                            <!-- Use mimikatz to remotely (via psexec) dump LSASS process content for RID 500 via code injection (new thread). Especially useful against domain controllers in Active Directory environments. It must be executed in the context of a user who is privileged on remote `machine`.The effect of `/inject` is explained in <https://blog.3or.de/mimikatz-deep-dive-on-lsadumplsa-patch-and-inject.html> -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">PsExec.exe;lsadump::lsa</ParentCommandLine>
                     </Rule>

                      <Rule name="T1055, Process Injection (Section View Injection)" groupRelation="and">                            <!-- creates a section object in the local process followed by a local section view. The shellcode is copied into the local section view and a remote section view is created in the target process, pointing to the local section view.  A thread is then created in the target process, using the remote section view as start address. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">Start-Process;InjectView.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055, Process Injection (Dirty Vanity process Injection)" groupRelation="and">                            <!-- used the Windows undocumented remote-fork API RtlCreateProcessReflection to create a cloned process of the parent process with shellcode written in its memory. The shellcode is executed after being forked to the child process. The technique was first presented at  BlackHat Europe 2022. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">redVanity.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055, Process Injection (Read-Write-Execute process Injection)" groupRelation="and">                            <!-- exploited the vulnerability in legitimate PE formats where sections have RWX permission and enough space for shellcode. The RWX injection avoided the use of VirtualAlloc, WriteVirtualMemory, and ProtectVirtualMemory, thus evading detection mechanisms  that relied on API call sequences and heuristics. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">searchVuln.exe;RWXinjectionLocal.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055, Process Injection (Process Injection with Go using UuidFromStringA WinAPI)" groupRelation="and">                            <!-- Uses WinAPI UuidFromStringA to load shellcode to a memory address then executes the shellcode using EnumSystemLocalesA. With this technique, memory is allocated on the heap and does not use commonly suspicious APIs such as VirtualAlloc, WriteProcessMemory, or CreateThread  - PoC Credit: (https://github.com/Ne0nd0g/go-shellcode/tree/master#uuidfromstringa) - References:    - https://research.nccgroup.com/2021/01/23/rift-analysing-a-lazarus-shellcode-execution-method/   - https://twitter.com/_CPResearch_/status/1352310521752662018   - https://blog.securehat.co.uk/process-injection/shellcode-execution-via-enumsystemlocala -->
                         <Image condition="contains">calc.exe</Image>
                         <ParentCommandLine condition="contains">UuidFromStringA.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055, Process Injection (Process Injection with Go using EtwpCreateEtwThread WinAPI)" groupRelation="and">                            <!-- Uses EtwpCreateEtwThread function from ntdll.dll to execute shellcode within the application's process. This program loads the DLLs and gets a handle to the used procedures itself instead of using the windows package directly. Steps taken with this technique 1. Allocate memory for the shellcode with VirtualAlloc setting the page permissions to Read/Write 2. Use the RtlCopyMemory macro to copy the shellcode to the allocated memory space 3. Change the memory page permissions to Execute/Read with VirtualProtect 4. Call EtwpCreateEtwThread on shellcode address 5. Call WaitForSingleObject so the program does not end before the shellcode is executed - PoC Credit: (https://github.com/Ne0nd0g/go-shellcode/tree/master#EtwpCreateEtwThread) - References:    - https://gist.github.com/TheWover/b2b2e427d3a81659942f4e8b9a978dc3   - https://www.geoffchappell.com/studies/windows/win32/ntdll/api/etw/index.htm -->
                         <Image condition="contains">calc.exe</Image>
                         <ParentCommandLine condition="contains">EtwpCreateEtwThread.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055, Process Injection (Remote Process Injection with Go using RtlCreateUserThread WinAPI)" groupRelation="and">                            <!-- Executes shellcode in a remote process. Steps taken with this technique 1. Get a handle to the target process 2. Allocate memory for the shellcode with VirtualAllocEx setting the page permissions to Read/Write 3. Use the WriteProcessMemory to copy the shellcode to the allocated memory space in the remote process 4. Change the memory page permissions to Execute/Read with VirtualProtectEx 5. Execute the entrypoint of the shellcode in the remote process with RtlCreateUserThread 6. Close the handle to the remote process - PoC Credit: (https://github.com/Ne0nd0g/go-shellcode/tree/master#rtlcreateuserthread) - References:    - https://www.cobaltstrike.com/blog/cobalt-strikes-process-injection-the-details-cobalt-strike -->
                         <Image condition="contains">powershell.exe</Image>
                         <ParentCommandLine condition="contains">RtlCreateUserThread.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055, Process Injection (Remote Process Injection with Go using CreateRemoteThread WinAPI)" groupRelation="and">                            <!-- Leverages the Windows CreateRemoteThread function from Kernel32.dll to execute shellocde in a remote process. This application leverages functions from the golang.org/x/sys/windows package, where feasible, like the windows.OpenProcess(). Steps taken with this technique 1. Get a handle to the target process 2. Allocate memory for the shellcode with VirtualAllocEx setting the page permissions to Read/Write 3. Use the WriteProcessMemory to copy the shellcode to the allocated memory space in the remote process 4. Change the memory page permissions to Execute/Read with VirtualProtectEx 5. Execute the entrypoint of the shellcode in the remote process with CreateRemoteThread 6. Close the handle to the remote process - PoC Credit: (https://github.com/Ne0nd0g/go-shellcode#createremotethread)  - References:   - https://www.ired.team/offensive-security/code-injection-process-injection/process-injection -->
                         <Image condition="contains">powershell.exe</Image>
                         <ParentCommandLine condition="contains all">werfault.exe;CreateRemoteThread.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055, Process Injection (Remote Process Injection with Go using CreateRemoteThread WinAPI (Natively))" groupRelation="and">                            <!-- Leverages the Windows CreateRemoteThread function from Kernel32.dll to execute shellcode in a remote process. This program loads the DLLs and gets a handle to the used procedures itself instead of using the windows package directly. 1. Get a handle to the target process 2. Allocate memory for the shellcode with VirtualAllocEx setting the page permissions to Read/Write 3. Use the WriteProcessMemory to copy the shellcode to the allocated memory space in the remote process 4. Change the memory page permissions to Execute/Read with VirtualProtectEx 5. Execute the entrypoint of the shellcode in the remote process with CreateRemoteThread 6. Close the handle to the remote process - PoC Credit: (https://github.com/Ne0nd0g/go-shellcode#createremotethreadnative) -->
                         <Image condition="contains">powershell.exe</Image>
                         <ParentCommandLine condition="contains all">werfault.exe;CreateRemoteThreadNative.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055, Process Injection (Process Injection with Go using CreateThread WinAPI)" groupRelation="and">                            <!-- This program executes shellcode in the current process using the following steps 1. Allocate memory for the shellcode with VirtualAlloc setting the page permissions to Read/Write 2. Use the RtlCopyMemory macro to copy the shellcode to the allocated memory space 3. Change the memory page permissions to Execute/Read with VirtualProtect 4. Call CreateThread on shellcode address 5. Call WaitForSingleObject so the program does not end before the shellcode is executed This program leverages the functions from golang.org/x/sys/windows to call Windows procedures instead of manually loading them - PoC Credit: (https://github.com/Ne0nd0g/go-shellcode#createthread) -->
                         <Image condition="contains">calc.exe</Image>
                         <ParentCommandLine condition="contains">CreateThread.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055, Process Injection (PProcess Injection with Go using CreateThread WinAPI (Natively))" groupRelation="and">                            <!-- This program executes shellcode in the current process using the following steps 1. Allocate memory for the shellcode with VirtualAlloc setting the page permissions to Read/Write 2. Use the RtlCopyMemory macro to copy the shellcode to the allocated memory space 3. Change the memory page permissions to Execute/Read with VirtualProtect 4. Call CreateThread on shellcode address 5. Call WaitForSingleObject so the program does not end before the shellcode is executed This program loads the DLLs and gets a handle to the used procedures itself instead of using the windows package directly. - PoC Credit: (https://github.com/Ne0nd0g/go-shellcode#createthreadnative) -->
                         <Image condition="contains">calc.exe</Image>
                         <ParentCommandLine condition="contains">CreateThreadNative.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055, Process Injection (UUID custom process Injection)" groupRelation="and">                            <!-- The UUIDs Process Injection code was first introduced by the NCC Group. The code can be stored in UUID forms on the heap and converted back to binary via UuidFromStringA at runtime. In this new custom version of UUID injection, EnumSystemLocalesA is the only API called to execute the code. We used custom UuidToString and UuidFromString implementations to avoid using UuidFromStringA and RPCRT4.dll, thereby eliminating the static signatures. This technique also avoided the use of VirtualAlloc, WriteProcessMemory and CreateThread The injected shellcode will open a message box and a notepad. Reference to NCC Group: https://research.nccgroup.com/2021/01/23/rift-analysing-a-lazarus-shellcode-execution-method/ Concept from: http://ropgadget.com/posts/abusing_win_functions.html -->
                         <Image condition="contains">powershell.exe</Image>
                         <ParentCommandLine condition="contains">uuid_injection.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055-001, Process Injection: Dynamic-link Library Injection (Process Injection via mavinject.exe)" groupRelation="and">                            <!-- Windows 10 Utility To Inject DLLS. Upon successful execution, powershell.exe will download T1055.dll to disk. Powershell will then spawn mavinject.exe to perform process injection in T1055.dll. With default arguments, expect to see a MessageBox, with notepad's icon in taskbar. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">mavinject</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055-002, Process Injection: Portable Executable Injection (Portable Executable Injection)" groupRelation="and">                            <!-- Injects a portable executable into a remote Notepad process memory using Portable Executable Injection and base-address relocation techniques. When successful, a message box will appear with the title "Warning" and the content "Atomic Red Team" after a few seconds. -->
                         <Image condition="contains">notepad.exe</Image>
                         <ParentCommandLine condition="contains">RedInjection.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055-003, Thread Execution Hijacking (Thread Execution Hijacking)" groupRelation="and">                            <!-- Injects a MessageBox shellcode generated by msfvenom in Notepad.exe using Thread Execution Hijacking. When successful, a message box will appear with the "Atomic Red Team" caption after one or two seconds. -->
                         <Image condition="contains">conhost.exe</Image>
                         <ParentCommandLine condition="contains">InjectContext.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055-004, Process Injection: Asynchronous Procedure Call (EarlyBird APC Queue Injection in Go)" groupRelation="and">                            <!-- Creates a process in a suspended state and calls QueueUserAPC WinAPI to add a UserAPC to the child process that points to allocated shellcode.  ResumeThread is called which then calls NtTestAlert to execute the created UserAPC which then executes the shellcode. This technique allows for the early execution of shellcode and potentially before AV/EDR can hook functions to support detection. - PoC Credit: (https://github.com/Ne0nd0g/go-shellcode#createprocesswithpipe) - References:    - https://www.bleepingcomputer.com/news/security/early-bird-code-injection-technique-helps-malware-stay-undetected/   - https://www.ired.team/offensive-security/code-injection-process-injection/early-bird-apc-queue-code-injection -->
                         <OriginalFileName condition="contains">WerFault.exe</OriginalFileName>
                         <ParentCommandLine condition="contains">EarlyBird.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055-012, Process Injection: Process Hollowing (Process Hollowing using PowerShell)" groupRelation="and">                            <!-- Uses PowerShell to create a Hollow from a PE on disk with explorer as the parent. Credit to FuzzySecurity (https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Start-Hollow.ps1) -->
                         <ParentImage condition="contains">WerFault.exe</ParentImage>
                         <ParentCommandLine condition="contains">Start-Hollow -Sponsor</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055-012, Process Injection: Process Hollowing (Process Hollowing in Go using CreateProcessW WinAPI)" groupRelation="and">                            <!-- Creates a process in a suspended state, executes shellcode to spawn calc.exe in a child process, and then resumes the original process. - PoC Credit: (https://github.com/Ne0nd0g/go-shellcode#createprocess) -->
                         <OriginalFileName condition="contains">WerFault.exe</OriginalFileName>
                         <ParentCommandLine condition="contains">CreateProcess.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055-012, Process Injection: Process Hollowing (Process Hollowing in Go using CreateProcessW and CreatePipe WinAPIs)" groupRelation="and">                            <!-- Create a process in a suspended state, execute shellcode to spawn calc.exe in a child process, and then resume the original process. This test uses the CreatePipe function to create an anonymous pipe that parent and child processes can communicate over. This anonymous pipe allows for the retrieval of output generated from executed shellcode. - PoC Credit: (https://github.com/Ne0nd0g/go-shellcode#createprocesswithpipe) -->
                         <OriginalFileName condition="contains">WerFault.exe</OriginalFileName>
                         <ParentCommandLine condition="contains">CreateProcessWithPipe.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1055-012, Process Injection: ListPlanting (Process injection ListPlanting)" groupRelation="and">                            <!-- Injects shellcode into a remote RegEdit process using the ListPlanting technique. ListPlanting exploits Window with ListView control. Code write to memory with NtWriteVirtualMemory. The shellcode is executed via PostMessage. When successful, a message box will appear with the title "Warning" and the content "Atomic Red Team" after a few seconds. Notepad will open following the appearance of the message box. -->
                         <ParentImage condition="contains">powerShell.exe</ParentImage>
                         <ParentCommandLine condition="contains">ListPlanting.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1140, Deobfuscate/Decode Files or Information (Deobfuscate/Decode Files Or Information)" groupRelation="and">                    <!-- Encode/Decode executable. -->
                         <OriginalFileName condition="is">CertUtil.exe</OriginalFileName>
                         <CommandLine condition="contains">certutil -encode</CommandLine>
                     </Rule>

                     <Rule name="T1140, Deobfuscate/Decode Files or Information (Certutil Rename and Decode)" groupRelation="and">                                 <!-- Rename certutil and decode a file. This is in reference to latest research by FireEye [here](https://www.fireeye.com/blog/threat-research/2018/09/apt10-targeting-japanese-corporations-using-updated-ttps.html). -->
                         <OriginalFileName condition="is">CertUtil.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">certutil.exe </ParentCommandLine>
                     </Rule>

                     <Rule name="T1006, Direct Volume Access (Read volume boot sector via DOS device path (PowerShell))" groupRelation="and">                   <!-- uses PowerShell to open a handle on the drive volume via the `\\.\` [DOS device path specifier](https://docs.microsoft.com/en-us/dotnet/standard/io/file-path-formats#dos-device-paths) and perform direct access read of the first few bytes of the volume. On success, a hex dump of the first 11 bytes of the volume is displayed. For a NTFS volume, it should correspond to the following sequence ([NTFS partition boot sector](https://en.wikipedia.org/wiki/NTFS#Partition_Boot_Sector_(VBR))): ``` 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F00000000   EB 52 90 4E 54 46 53 20 20 20 20  Ã«R?NTFS ``` -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">\\.\</ParentCommandLine>
                     </Rule>

                     <Rule name="T1070, Indicator Removal on Host (Indicator Removal using FSUtil)" groupRelation="and">                      <!-- Manages the update sequence number (USN) change journal, which provides a persistent log of all changes made to files on the volume. Upon execution, no output will be displayed. More information about fsutil can be found at https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/fsutil-usn -->   
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">fsutil usn deletejournal</ParentCommandLine>
                     </Rule>

                     <Rule name="T1070, Indicator Removal on Host (Indicator Manipulation using FSUtil)" groupRelation="and">                      <!-- Finds a file by user name (if Disk Quotas are enabled), queries allocated ranges for a file, sets a file's short name, sets a file's valid data length, sets zero data for a file, or creates a new file. Upon execution, no output will be displayed. More information about fsutil can be found at https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/fsutil-file - https://tria.ge/230601-x8x6bsgb24/behavioral2 -->   
                         <ParentImage condition="contains">powerShell.exe</ParentImage>
                         <ParentCommandLine condition="contains">fsutil  file setZeroData</ParentCommandLine>
                     </Rule>

                     <Rule name="T1070-001, Indicator Removal on Host: Clear Windows Event Logs (Clear Logs)" groupRelation="and">                      <!-- Upon execution this will clear Windows Event Logs. Open the System.evtx logs at C:\Windows\System32\winevt\Logs and verify that it is now empty. -->   
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">wevtutil cl</ParentCommandLine>
                     </Rule>

                     <Rule name="T1070-001, Indicator Removal on Host: Clear Windows Event Logs (Delete System Logs Using Clear-EventLog)" groupRelation="and">                      <!-- Clear event logs using built-in PowerShell commands. Upon successful execution, you should see the list of deleted event logs Upon execution, open the Security.evtx logs at C:\Windows\System32\winevt\Logs and verify that it is now empty or has very few logs in it. -->   
                         <ParentImage condition="contains">powerShell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Clear-EventLog -LogName </ParentCommandLine>
                     </Rule>

                     <Rule name="T1070-003, Indicator Removal on Host: Clear Command History (Prevent Powershell History Logging)" groupRelation="and">                      <!-- Prevents Powershell history. -->   
                         <Image condition="contains">powershell.exe</Image>
                         <CommandLine condition="contains">Set-PSReadlineOption</CommandLine>
                     </Rule>

                     <Rule name="T1070-003, Indicator Removal on Host: Clear Windows Event Logs (Clear Powershell History by Deleting History File)" groupRelation="and">                      <!-- Clears Powershell history. -->   
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Get-PSReadlineOption</ParentCommandLine>
                     </Rule>

                     <Rule name="T1070-003, Indicator Removal on Host: Clear Windows Event Logs (Set Custom AddToHistoryHandler to Avoid History File Logging)" groupRelation="and">                      <!-- Set Custom AddToHistoryHandler to Avoid History File Logging. -->   
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Set-PSReadLineOption -AddToHistoryHandler</ParentCommandLine>
                     </Rule>

                     <Rule name="T1070-004, Indicator Removal on Host: File Deletion (Delete a single file - Windows cmd)" groupRelation="and">                          <!-- Delete a single file - Windows cmd -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">del /f</ParentCommandLine>
                     </Rule>

                     <Rule name="T1070-004, Indicator Removal on Host: File Deletion (Delete an entire folder - Windows cmd)" groupRelation="and">                          <!-- Recursively delete a folder in the temporary directory using cmd.exe. Upon execution, no output will be displayed. Use File Explorer to verify the folder was deleted. -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">rmdir /s /q</ParentCommandLine>
                     </Rule>

                     <Rule name="T1070-004, Indicator Removal on Host: File Deletion (Delete a single file - Windows PowerShell)" groupRelation="and">                          <!-- Delete a single file from the temporary directory using Powershell. Upon execution, no output will be displayed. Use File Explorer to verify the file was deleted. -->
                         <ParentImage condition="contains">powerShell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Remove-Item -path</ParentCommandLine>
                     </Rule>

                     <Rule name="T1070-004, Indicator Removal on Host: File Deletion (Delete TeamViewer Log Files)" groupRelation="and">                          <!-- Adversaries may delete TeamViewer log files to hide activity. This should provide a high true-positive alert ration. This test just places the files in a non-TeamViewer folder, a detection would just check for a deletion event matching the TeamViewer log file format of TeamViewer_##.log. Upon execution, no output will be displayed. Use File Explorer to verify the folder was deleted. https://twitter.com/SBousseaden/status/1197524463304290305?s=20 -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">Remove-Item;TeamViewer</ParentCommandLine>
                     </Rule>

                     <Rule name="T1070-005, Indicator Removal on Host: Network Share Connection Removal (Remove Network Share PowerShell)" groupRelation="and">           <!-- Removes a Network Share utilizing PowerShell -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">Remove-SmbShare;Remove-FileShare</ParentCommandLine>
                     </Rule>

                     <Rule name="T1070-006, Indicator Removal on Host: Timestomp (Windows - Modify file creation timestamp with PowerShell)" groupRelation="and">           <!-- Modifies the file creation timestamp of a specified file. This technique was seen in use by the Stitch RAT. To verify execution, use File Explorer to view the Properties of the file and observe that the Created time is the year 1970. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">Get-ChildItem;CreationTime</ParentCommandLine>
                     </Rule>

                     <Rule name="T1070-006, Indicator Removal on Host: Timestomp (Windows - Modify file last modified timestamp with PowerShell)" groupRelation="and">           <!-- Modifies the file last modified timestamp of a specified file. This technique was seen in use by the Stitch RAT. To verify execution, use File Explorer to view the Properties of the file and observe that the Modified time is the year 1970. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">Get-ChildItem;LastWriteTime</ParentCommandLine>
                     </Rule>

                     <Rule name="T1070-006, Indicator Removal on Host: Timestomp (Windows - Modify file last access timestamp with PowerShell)" groupRelation="and">           <!-- Modifies the last access timestamp of a specified file. This technique was seen in use by the Stitch RAT. To verify execution, use File Explorer to view the Properties of the file and observe that the Accessed time is the year 1970. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">Get-ChildItem;LastAccessTime</ParentCommandLine>
                     </Rule>

                     <Rule name="T1036, Masquerading (System File Copied to Unusual Location)" groupRelation="and">                                                <!-- System File Copied to Unusual Location -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">$env:windir\System32\cmd.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1036, Masquerading (Malware Masquerading and Execution from Zip File)" groupRelation="and">                                      <!-- When the file is unzipped and the README.cmd file opened, it executes and changes the .pdf to .dll and executes the dll. This is a BazaLoader technique [as reported here](https://twitter.com/ffforward/status/1481672378639912960) -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Expand-Archive -Path</CommandLine>
                     </Rule>

                     <Rule name="T1036, Masquerading (Masquerading as Windows LSASS process)" groupRelation="and">                                                 <!-- Copies cmd.exe, renames it, and launches it to masquerade as an instance of lsass.exe. Upon execution, cmd will be launched by powershell. If using Invoke-AtomicTest, The test will hang until the 120 second timeout cancels the session. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <ParentCommandLine condition="contains">Temp\lsass.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1036, Masquerading (Masquerading - cscript.exe running as notepad.exe)" groupRelation="and">                                                 <!-- Copies cmd.exe, renames it, and launches it to masquerade as an instance of lsass.exe. Upon execution, cmd will be launched by powershell. If using Invoke-AtomicTest, The test will hang until the 120 second timeout cancels the session. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <ParentCommandLine condition="contains">System32\cscript.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1036, Masquerading (Masquerading - wscript.exe running as svchost.exe)" groupRelation="and">                                                 <!-- Copies wscript.exe, renames it, and launches it to masquerade as an instance of svchost.exe. Upon execution, no windows will remain open but wscript will have been renamed to svchost and ran out of the temp folder. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <ParentCommandLine condition="contains">APPDATA%\svchost.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1036, Masquerading (Masquerading - powershell.exe running as taskhostw.exe)" groupRelation="and">                                            <!-- Copies powershell.exe, renames it, and launches it to masquerade as an instance of taskhostw.exe. Upon successful execution, powershell.exe is renamed as taskhostw.exe and executed from non-standard path. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <ParentCommandLine condition="contains">APPDATA%\taskhostw.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1036, Masquerading (Malicious process Masquerading as LSM.exe)" groupRelation="and">                                                         <!-- Detect LSM running from an incorrect directory and an incorrect service account This works by copying cmd.exe to a file, naming it lsm.exe, then copying a file to the C:\ folder. Upon successful execution, cmd.exe will be renamed as lsm.exe and executed from non-standard path. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <ParentCommandLine condition="contains">lsm.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1036, Masquerading (Creating W32Time similar named service using schtasks)" groupRelation="and">                                             <!-- Creating W32Time similar named service (win32times) using schtasks just like threat actor dubbed "Operation Wocao" -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">schtasks /create</ParentCommandLine>
                     </Rule>

                     <Rule name="T1036, Masquerading (Creating W32Time similar named service using schtasks)" groupRelation="and">                                             <!-- Creating W32Time similar named service using sc. -->
                         <OriginalFileName condition="is">sc.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">sc create win32times</ParentCommandLine>
                     </Rule>    

                     <Rule name="T1036, Masquerading (Creating W32Time similar named service using schtasks)" groupRelation="and">                                             <!-- Launch an executable that attempts to masquerade as a legitimate executable. -->
                         <OriginalFileName condition="is">csc.exe</OriginalFileName>
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Add-Type -TypeDefinition</ParentCommandLine>
                     </Rule>

                     <Rule name="T1036-003, Masquerading: Rename System Utilities (Masquerading as Windows LSASS process)" groupRelation="and">                       <!-- Copies cmd.exe, renames it, and launches it to masquerade as an instance of lsass.exe. Upon execution, cmd will be launched by powershell. If using Invoke-AtomicTest, The test will hang until the 120 second timeout cancels the session -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">cmd.exe;lsass.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1036-003, Masquerading: Rename System Utilities (Masquerading - wscript.exe running as svchost.exe)" groupRelation="and">                       <!-- Copies wscript.exe, renames it, and launches it to masquerade as an instance of svchost.exe. Upon execution, no windows will remain open but wscript will have been renamed to svchost and ran out of the temp folder -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">wscript.exe;svchost.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1036-003, Masquerading: Rename System Utilities (Masquerading - powershell.exe running as taskhostw.exe)" groupRelation="and">                       <!-- Copies powershell.exe, renames it, and launches it to masquerade as an instance of taskhostw.exe. Upon successful execution, powershell.exe is renamed as taskhostw.exe and executed from non-standard path. -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">powershell.exe;taskhostw.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1036-003, Masquerading: Rename System Utilities (Malicious process Masquerading as LSM.exe)" groupRelation="and">                       <!-- Detect LSM running from an incorrect directory and an incorrect service account This works by copying cmd.exe to a file, naming it lsm.exe, then copying a file to the C:\ folder. Upon successful execution, cmd.exe will be renamed as lsm.exe and executed from non-standard path. -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">cmd.exe;lsm.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1036-004, Masquerading: Masquerade Task or Service (Creating W32Time similar named service using schtasks)" groupRelation="and">                       <!-- Creating W32Time similar named service (win32times) using schtasks just like threat actor dubbed "Operation Wocao" -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">schtasks /query /tn win32times</ParentCommandLine>
                     </Rule>

                     <Rule name="T1036-004, Masquerading: Masquerade Task or Service (Creating W32Time similar named service using sc)" groupRelation="and">                       <!-- Creating W32Time similar named service (win32times) using sc just like threat actor dubbed "Operation Wocao" -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">sc qc win32times</ParentCommandLine>
                     </Rule>

                     <Rule name="T1036-005, Masquerading: Match Legitimate Name or Location (Masquerade as a built-in system executable)" groupRelation="and">                       <!-- Launch an executable that attempts to masquerade as a legitimate executable. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">OutputAssembly;Start-Process</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Modify Registry of Current User Profile - cmd)" groupRelation="and">                                                      <!-- Modify the registry of the currently logged in user using reg.exe via cmd console. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Modify registry to store logon credentials)" groupRelation="and">                                                         <!-- Modify the Local Machine registry RUN key to change Windows Defender executable that should be ran on startup. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Modify Registry of Local Machine - cmd)" groupRelation="and">                                                             <!-- Sets registry key that will tell windows to store plaintext passwords (making the system vulnerable to clear text / cleartext password dumping). -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Use Powershell to Modify registry to store logon credentials)" groupRelation="and">                                       <!-- Sets registry key using Powershell that will tell windows to store plaintext passwords (making the system vulnerable to clear text / cleartext password dumping). --> 
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">'HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest'</CommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Javascript in registry)" groupRelation="and">                                                                             <!-- A javascript block will be placed in the registry for persistence. --> 
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">"HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings</CommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Change Powershell Execution Policy to Bypass)" groupRelation="and">                                                       <!-- Attackers need to change the powershell execution policy in order to run their malicious powershell scripts. They can either specify it during the execution of the powershell script or change the registry value for it. --> 
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Set-ExecutionPolicy -ExecutionPolicy Bypass</CommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (BlackByte Ransomware Registry Changes - CMD)" groupRelation="and">                                                        <!--  See "Preparing to Worm" section: https://redcanary.com/blog/blackbyte-ransomware/ The steps are as follows: <ol>     <li>1. Elevate Local Privilege by disabling UAC Remote Restrictions</li>     <li>2. Enable OS to share network connections between different privilege levels</li>     <li>3. Enable long path values for file paths, names, and namespaces to ensure encryption of all file names and paths</li> </ol> The registry keys and their respective values will be created upon successful execution. -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">LocalAccountTokenFilterPolicy; EnableLinkedConnections; LongPathsEnabled</ParentCommandLine>
                     </Rule>    

                     <Rule name="T1112, Modify Registry (BlackByte Ransomware Registry Changes - Powershell)" groupRelation="and">                                                 <!-- See "Preparing to Worm" section: https://redcanary.com/blog/blackbyte-ransomware/ The steps are as follows: <ol>     <li>1. Elevate Local Privilege by disabling UAC Remote Restrictions</li>     <li>2. Enable OS to share network connections between different privilege levels</li>     <li>3. Enable long path values for file paths, names, and namespaces to ensure encryption of all file names and paths</li> </ol> The registry keys and their respective values will be created upon successful execution. -->
                         <OriginalFileName condition="contains">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains all">LocalAccountTokenFilterPolicy; EnableLinkedConnections; -PropertyType DWord</CommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Disable Windows Registry Tool)" groupRelation="and">                                                                      <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to disable the windows registry tool to prevent user modifying registry entry. See example how Agent Tesla malware abuses this technique: https://any.run/report/ea4ea08407d4ee72e009103a3b77e5a09412b722fdef67315ea63f22011152af/a866d7b1-c236-4f26-a391-5ae32213dfc4#registry. -->      
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <CommandLine condition="contains">DisableRegistryTools</CommandLine>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Disable Windows CMD application)" groupRelation="and">                                                                    <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to disable the windows CMD application. See example how Agent Tesla malware abuses this technique: https://any.run/report/ea4ea08407d4ee72e009103a3b77e5a09412b722fdef67315ea63f22011152af/a866d7b1-c236-4f26-a391-5ae32213dfc4#registry -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">DisableCMD</CommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Disable Windows Task Manager application)" groupRelation="and">                                                           <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to disable the windows task manager application. See example how Agent Tesla malware abuses this technique: https://any.run/report/ea4ea08407d4ee72e009103a3b77e5a09412b722fdef67315ea63f22011152af/a866d7b1-c236-4f26-a391-5ae32213dfc4#registry -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">DisableTaskmgr</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Disable Windows Notification Center)" groupRelation="and">                                                                <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to disable the windows notification center. See how remcos rat abuses this technique- https://tccontre.blogspot.com/2020/01/remcos-rat-evading-windows-defender-av.html -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">DisableNotificationCenter</ParentCommandLine>
                     </Rule>    

                     <Rule name="T1112, Modify Registry (Disable Windows Shutdown Button)" groupRelation="and">                                                                <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to disable the windows shutdown button. See how ransomware abuses this technique- https://www.trendmicro.com/vinfo/us/threat-encyclopedia/malware/ransom.msil.screenlocker.a/ -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">shutdownwithoutlogon</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Disable Windows LogOff Button)" groupRelation="and">                                                                  <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to disable the windows logoff button. See how ransomware abuses this technique- https://www.trendmicro.com/vinfo/be/threat-encyclopedia/search/js_noclose.e/2 --> 
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">NoLogOff; StartMenuLogOff</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Disable Windows Change Password Feature)" groupRelation="and">                                                        <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to disable the windows change password feature. See how ransomware abuses this technique- https://www.trendmicro.com/vinfo/us/threat-encyclopedia/malware/ransom_heartbleed.thdobah -->     
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">DisableChangePassword</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Disable Windows Lock Workstation Feature)" groupRelation="and">                                                       <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to disable the windows Lock workstation feature. See how ransomware abuses this technique- https://www.bleepingcomputer.com/news/security/in-dev-ransomware-forces-you-do-to-survey-before-unlocking-computer/ -->     
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">DisableLockWorkstation</ParentCommandLine>
                     </Rule>    

                     <Rule name="T1112, Modify Registry (Activate Windows NoDesktop Group Policy Feature)" groupRelation="and">                                                <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to hide all icons on Desktop Group Policy.  Take note that some Group Policy changes might require a restart to take effect. See how Trojan abuses this technique- https://www.sophos.com/de-de/threat-center/threat-analyses/viruses-and-spyware/Troj~Krotten-N/detailed-analysis -->     
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">NoDesktop</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Activate Windows NoRun Group Policy Feature)" groupRelation="and">                                                    <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to Remove Run menu from Start Menu Group Policy. Take note that some Group Policy changes might require a restart to take effect. See how Trojan abuses this technique- https://www.sophos.com/de-de/threat-center/threat-analyses/viruses-and-spyware/Troj~Krotten-N/detailed-analysis -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">NoRun</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Activate Windows NoFind Group Policy Feature)" groupRelation="and">                                                   <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to Remove Search menu from Start Menu Group Policy. Take note that some Group Policy changes might require a restart to take effect. See how Trojan abuses this technique- https://www.sophos.com/de-de/threat-center/threat-analyses/viruses-and-spyware/Troj~Krotten-N/detailed-analysis -->    
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">NoFind</ParentCommandLine>
                     </Rule>    

                     <Rule name="T1112, Modify Registry (Activate Windows NoControlPanel Group Policy Feature)" groupRelation="and">                                           <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to Disable Control Panel Group Policy.  Take note that some Group Policy changes might require a restart to take effect. See how Trojan abuses this technique- https://www.sophos.com/de-de/threat-center/threat-analyses/viruses-and-spyware/Troj~Krotten-N/detailed-analysis. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">NoControlPanel</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Activate Windows NoFileMenu Group Policy Feature)" groupRelation="and">                                               <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to Remove File menu from Windows Explorer Group Policy.  Take note that some Group Policy changes might require a restart to take effect. See how Trojan abuses this technique- https://www.sophos.com/de-de/threat-center/threat-analyses/viruses-and-spyware/Troj~Krotten-N/detailed-analysis -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">NoFileMenu</ParentCommandLine>
                     </Rule>    

                     <Rule name="T1112, Modify Registry (Activate Windows NoClose Group Policy Feature)" groupRelation="and">                                                  <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to Disable and remove the Shut Down command Group Policy.  Take note that some Group Policy changes might require a restart to take effect. See how Trojan abuses this technique- https://www.sophos.com/de-de/threat-center/threat-analyses/viruses-and-spyware/Troj~Krotten-N/detailed-analysis -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">NoClose</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Activate Windows NoSetTaskbar Group Policy Feature)" groupRelation="and">                                             <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to Disable changes to Taskbar and Start Menu Settings Group Policy.  Take note that some Group Policy changes might require a restart to take effect. See how ransomware abuses this technique- https://www.virustotal.com/gui/file/2d7855bf6470aa323edf2949b54ce2a04d9e38770f1322c3d0420c2303178d91/details -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">NoSetTaskbar</ParentCommandLine>
                     </Rule>
  
                     <Rule name="T1112, Modify Registry (Activate Windows NoTrayContextMenu Group Policy Feature)" groupRelation="and">                    <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to Disable context menu for taskbar Group Policy.  Take note that some Group Policy changes might require a restart to take effect. See how ransomware abuses this technique- https://www.virustotal.com/gui/file/2d7855bf6470aa323edf2949b54ce2a04d9e38770f1322c3d0420c2303178d91/details -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">NoTrayContextMenu</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Activate Windows NoPropertiesMyDocuments Group Policy Feature)" groupRelation="and">              <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to hide Properties from "My Documents icon" Group Policy.  Take note that some Group Policy changes might require a restart to take effect. See how ransomware abuses this technique- https://www.virustotal.com/gui/file/2d7855bf6470aa323edf2949b54ce2a04d9e38770f1322c3d0420c2303178d91/details -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">NoPropertiesMyDocuments</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Hide Windows Clock Group Policy Feature)" groupRelation="and">                                    <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to Hide Clock Group Policy.  Take note that some Group Policy changes might require a restart to take effect. See how ransomware abuses this technique- https://www.virustotal.com/gui/file/2d7855bf6470aa323edf2949b54ce2a04d9e38770f1322c3d0420c2303178d91/details -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">HideClock</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Windows HideSCAHealth Group Policy Feature)" groupRelation="and">                                 <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to remove security and maintenance icon Group Policy.  Take note that some Group Policy changes might require a restart to take effect. See how ransomware abuses this technique- https://www.virustotal.com/gui/file/2d7855bf6470aa323edf2949b54ce2a04d9e38770f1322c3d0420c2303178d91/details -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">HideSCAHealth</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Windows HideSCANetwork Group Policy Feature)" groupRelation="and">                                <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to remove the networking icon Group Policy.  Take note that some Group Policy changes might require a restart to take effect. See how ransomware abuses this technique- https://www.virustotal.com/gui/file/2d7855bf6470aa323edf2949b54ce2a04d9e38770f1322c3d0420c2303178d91/details -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">HideSCANetwork</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Windows HideSCAPower Group Policy Feature)" groupRelation="and">                                  <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to remove the battery icon Group Policy.  Take note that some Group Policy changes might require a restart to take effect. See how ransomware abuses this technique- https://www.virustotal.com/gui/file/2d7855bf6470aa323edf2949b54ce2a04d9e38770f1322c3d0420c2303178d91/details -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">HideSCAPower</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Windows HideSCAVolume Group Policy Feature)" groupRelation="and">                                  <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to remove the volume icon Group Policy.  Take note that some Group Policy changes might require a restart to take effect.. See how ransomware abuses this technique- https://www.virustotal.com/gui/file/2d7855bf6470aa323edf2949b54ce2a04d9e38770f1322c3d0420c2303178d91/details -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">HideSCAVolume</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Windows Modify Show Compress Color And Info Tip Registry)" groupRelation="and">                                  <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to show compress color and show tips feature.  See how hermeticwiper uses this technique - https://www.splunk.com/en_us/blog/security/detecting-hermeticwiper.html -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">ShowInfoTip; ShowCompColor</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Windows Powershell Logging Disabled)" groupRelation="and">                                  <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to disable Powershell Module Logging, Script Block Logging, Transcription and Script Execution see https://admx.help/?Category=Windows_10_2016&Policy=Microsoft.Policies.PowerShell::EnableModuleLogging -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">EnableModuleLogging; EnableScriptBlockLogging</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Disable Windows Toast Notifications)" groupRelation="and">                                  <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to disable the windows toast notification. See how azorult malware abuses this technique- https://app.any.run/tasks/a6f2ffe2-e6e2-4396-ae2e-04ea0143f2d8/ -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">ToastEnabled</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Disable Windows Security Center Notifications)" groupRelation="and">                        <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to disable the windows security center notification. See how azorult malware abuses this technique- https://app.any.run/tasks/a6f2ffe2-e6e2-4396-ae2e-04ea0143f2d8/ -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">UseActionCenterExperience</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Suppress Win Defender Notifications)" groupRelation="and">                                  <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to suppress the windows defender notification. See how azorult malware abuses this technique- https://app.any.run/tasks/a6f2ffe2-e6e2-4396-ae2e-04ea0143f2d8/ -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">Notification_Suppress</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Allow RDP Remote Assistance Feature)" groupRelation="and">                                  <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to allow rdp remote assistance feature. This feature allow specific user to rdp connect on the targeted machine. See how azorult malware abuses this technique- https://app.any.run/tasks/a6f2ffe2-e6e2-4396-ae2e-04ea0143f2d8/ -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">fAllowToGetHelp</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (NetWire RAT Registry Key Creation)" groupRelation="and">                                    <!-- NetWire continues to create its home key (HKCU\SOFTWARE\NetWire) as well as adding it into the auto-run group in the victimâ€™s registry. See how NetWire malware - https://app.any.run/tasks/41ecdbde-4997-4301-a350-0270448b4c8f/ -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">NetWire; HostId</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Ursnif Malware Registry Key Creation)" groupRelation="and">                                 <!-- Ursnif downloads additional modules from the C&C server and saves these in the registry folder HKEY_CURRENT_USER\Software\AppDataLow\Software\Microsoft\ More information - https://blog.trendmicro.com/trendlabs-security-intelligence/phishing-campaign-uses-hijacked-emails-to-deliver-ursnif-by-replying-to-ongoing-threads/ -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">comsxRes</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Terminal Server Client Connection History Cleared)" groupRelation="and">                    <!-- The built-in Windows Remote Desktop Connection (RDP) client (mstsc.exe) saves the remote computer name (or IP address) and the username that is used to login after each successful connection to the remote computer -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">delete; "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default"; "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers"</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Disable Windows Error Reporting Settings)" groupRelation="and">                             <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to disable windows error reporting settings. This Windows feature allow the use to report bug, errors, failure or problems  encounter in specific application or process. See how azorult malware abuses this technique- https://app.any.run/tasks/a6f2ffe2-e6e2-4396-ae2e-04ea0143f2d8/ -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">DisableEnhancedNotifications</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (DisallowRun Execution Of Certain Applications)" groupRelation="and">                        <!-- Modify the registry of the currently logged in user using reg.exe via cmd console to prevent user running specific computer programs that could aid them in manually removing malware or detecting it  using security product. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">DisallowRun</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Enabling Restricted Admin Mode via Command_Prompt)" groupRelation="and">                    <!-- Enabling Restricted Admin Mode via Command_Prompt,enables an attacker to perform a pass-the-hash attack using RDP.See [Passing the Hash with Remote Desktop](https://www.kali.org/blog/passing-hash-remote-desktop/) -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">DisableRestrictedAdmin</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Mimic Ransomware - Enable Multiple User Sessions)" groupRelation="and">                     <!-- Mimic ransomware's ability to enable multiple user sessions by modifying the AllowMultipleTSSessions value within the Winlogon registry key.  See [Mimic Ransomware Overview] (https://www.trendmicro.com/en_us/research/23/a/new-mimic-ransomware-abuses-everything-apis-for-its-encryption-p.html) -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">AllowMultipleTSSessions</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Mimic Ransomware - Allow Multiple RDP Sessions per User)" groupRelation="and">              <!-- Mimic ransomware's ability to enable multiple RDP sessions per user by modifying the fSingleSessionPerUser value within the Terminal Server registry key.  See [Mimic Ransomware Overview] (https://www.trendmicro.com/en_us/research/23/a/new-mimic-ransomware-abuses-everything-apis-for-its-encryption-p.html) -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">fSingleSessionPerUser</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Event Viewer Registry Modification - Redirection URL)" groupRelation="and">                 <!-- Modify event viewer registry values to alter the behavior of the online help redirection. Upon opening an event in event viewer and attempting to view the help page for the event, it will open the URL or execute the program defined in the redirection URL registry entry. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">MicrosoftRedirectionURL</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Event Viewer Registry Modification - Redirection Program)" groupRelation="and">             <!-- Modify the registry value of fDenyTSConnections to allow incoming RDP connections.  This activity has been observed by multiple ransomware groups, including Hive ransomware.  [Reference](https://www.rapid7.com/blog/post/2023/01/11/increasing-the-sting-of-hive-ransomware/) -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">MicrosoftRedirectionProgram</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Enabling Remote Desktop Protocol via Remote Registry)" groupRelation="and">                 <!-- Enabling RDP through remote registry. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">SecurityLayer</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Disable Win Defender Notification)" groupRelation="and">                                    <!-- Disable Win Defender Notification. Redline is using this to disable this win defender feature. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">DisableNotifications</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Disable Windows OS Auto Update)" groupRelation="and">                                       <!-- Disable Auto Update Windows OS feature. Redline is using this as part of its defense evasion. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">NoAutoUpdate</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Disable Windows Auto Reboot for current logon user)" groupRelation="and">                   <!-- Disable Windows Auto Reboot for current logon user. Redline is using this as part of its defense evasion. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">NoAutoRebootWithLoggedOnUsers</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Disable Windows Auto Reboot for current logon user)" groupRelation="and">                   <!-- Disable Windows Auto Reboot for current logon user. Redline is using this as part of its defense evasion. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">NoAutoRebootWithLoggedOnUsers</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Windows Auto Update Option to Notify before download)" groupRelation="and">                 <!-- Windows Auto Update Option to Notify before download. Redline is using this as part of its defense evasion. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">AUOptions</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Do Not Connect To Win Update)" groupRelation="and">                                         <!-- Do Not Connect To Win Update. Redline is using this as part of its defense evasion. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">DoNotConnectToWindowsUpdateInternetLocations</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Tamper Win Defender Protection)" groupRelation="and">                                       <!-- Tamper Win Defender Protection. RedLine Stealer is executing another component file to modify this win defender feature in registry.  Take note that this modification might not be enough to disable this feature but can be a good indicator of malicious process that  tries to tamper this Win Defender feature settings. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">TamperProtection</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Allow Simultaneous Download Registry)" groupRelation="and">                                 <!--  A registry modification to allow Simultaneous download in the system. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">MaxConnectionsPerServer</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Activities To Disable Secondary Authentication Detected By Modified Registry Value)" groupRelation="and">                                 <!--  disable secondary authentication activities that adversary attempt to bypass MFA and to get the unauthorized access to the system or sensitive data. See the related article (https://admx.help/?Category=Windows_10_2016&Policy=Microsoft.Policies.SecondaryAuthenticationFactor::MSSecondaryAuthFactor_AllowSecondaryAuthenticationDevice). -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">AllowSecondaryAuthenticationDevice</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Activities To Disable Microsoft [FIDO Aka Fast IDentity Online] Authentication Detected By Modified Registry Value)" groupRelation="and">                                 <!-- Detect the Microsoft FIDO authentication disable activities that adversary attempt to gains access to login credentials (e.g., passwords), they may be able to impersonate the user and access sensitive accounts or data and also increases the risk of falling victim to phishing attacks. See the related article (https://admx.help/?Category=Windows_10_2016&Policy=Microsoft.Policies.FidoAuthentication::AllowFidoDeviceSignon). -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">AllowExternalDeviceSignon</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Scarab Ransomware Defense Evasion Activities)" groupRelation="and">                                 <!-- Scarab Ransomware defense evasion activities that can abuse the registry values to modify the settings of the Credential Security Support Provider to overcome potential RDP connection issues. [Scarab Ransomware Article](https://www.welivesecurity.com/en/eset-research/scarabs-colon-izing-vulnerable-servers/) -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">AllowEncryptionOracle</ParentCommandLine>
                     </Rule> 

                     <Rule name="T1112, Modify Registry (Disable Remote Desktop Anti-Alias Setting Through Registry)" groupRelation="and">                                 <!-- A modification registry to disable RDP anti-alias settings. This technique was seen in DarkGate malware as part of its installation -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">DisableRemoteDesktopAntiAlias</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Disable Remote Desktop Security Settings Through Registry)" groupRelation="and">                                  <!-- A modification registry to disable RDP security settings. This technique was seen in DarkGate malware as part of its installation -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">DisableSecuritySettings</ParentCommandLine>
                     </Rule> 

                     <Rule name="T1112, Modify Registry (Disabling ShowUI Settings of Windows Error Reporting (WER))" groupRelation="and">                                 <!-- A modification registry to disable ShowUI settings of Windows Error Report. This registry setting can influence the behavior of error reporting dialogs or prompt box.  This technique was seen in DarkGate malware as part of its installation. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">DontShowUI</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Enable Proxy Settings)" groupRelation="and">                                 <!-- A modification registry to enable proxy settings. This technique was seen in DarkGate malware as part of its installation. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">ProxyEnable</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Enable Proxy Settings)" groupRelation="and">                                 <!-- A modification registry to enable proxy settings. This technique was seen in DarkGate malware as part of its installation. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">ProxyEnable</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Set-Up Proxy Server)" groupRelation="and">                                   <!-- A modification registry to setup proxy server. This technique was seen in DarkGate malware as part of its installation. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">ProxyServer</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (RDP Authentication Level Override)" groupRelation="and">                     <!-- A modification registry to override RDP Authentication Level. This technique was seen in DarkGate malware as part of its installation. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">AuthenticationLevelOverride</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Enable RDP via Registry (fDenyTSConnections))" groupRelation="and">                  <!-- Modify the registry value of fDenyTSConnections to allow incoming RDP connections.  This activity has been observed by multiple ransomware groups, including Hive ransomware.  [Reference](https://www.rapid7.com/blog/post/2023/01/11/increasing-the-sting-of-hive-ransomware/) -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">fDenyTSConnections</ParentCommandLine>
                     </Rule>

                     <Rule name="T1112, Modify Registry (Disable Windows Prefetch Through Registry)" groupRelation="and">                     <!-- Modify the registry of the machine to disable prefetch. Disabling prefetch will remove one artifact for evidence of application execution. Restart is required post modification. -->
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">EnablePrefetcher</ParentCommandLine>
                     </Rule>

                     <Rule name="T1072, Software Deployment Tools (Radmin Viewer Utility)" groupRelation="and">                         <!-- An adversary may use Radmin Viewer Utility to remotely control Windows device, this will start the radmin console. -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">Radmin</ParentCommandLine>
                     </Rule>

                     <Rule name="T1072, Software Deployment Tools (PDQ Deploy RAT)" groupRelation="and">                         <!-- An adversary may use PDQ Deploy Software to deploy the Remote Adminstartion Tool, this will start the PDQ console. -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">PDQ</ParentCommandLine>
                     </Rule>

                     <Rule name="T1072, Software Deployment Tools (Deploy 7-Zip Using Chocolatey)" groupRelation="and">                         <!-- An adversary may use Chocolatey to remotely deploy the 7-Zip file archiver utility. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">choco install -y 7zip</ParentCommandLine>
                     </Rule>

                     <Rule name="T1550-002, Use Alternate Authentication Material: Pass the Hash (Mimikatz Pass the Hash)" groupRelation="and">                         <!-- Note: must dump hashes first [Reference](https://github.com/gentilkiwi/mimikatz/wiki/module-~-sekurlsa#pth) -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">mimikatz;sekurlsa::pth</ParentCommandLine>
                     </Rule>

                     <Rule name="T1550-002, Use Alternate Authentication Material: Pass the Hash (crackmapexec Pass the Hash)" groupRelation="and">                         <!-- command execute with crackmapexec -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">crackmapexec.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1550-002, Use Alternate Authentication Material: Pass the Hash (Invoke-WMIExec Pass the Hash)" groupRelation="and">                         <!-- Use Invoke-WMIExec to Pass the Hash Note: must dump hashes first [Reference](https://github.com/gentilkiwi/mimikatz/wiki/module-~-sekurlsa#pth) -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-WMIExec -Target</ParentCommandLine>
                     </Rule>

                     <Rule name="T1550-003, Use Alternate Authentication Material: Pass the Ticket (Mimikatz Kerberos Ticket Attack)" groupRelation="and">                         <!-- Similar to PTH, but attacking Kerberos -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">mimikatz;kerberos::ptt</ParentCommandLine>
                     </Rule>

                     <Rule name="T1550-002, Use Alternate Authentication Material: Pass the Hash (Rubeus Kerberos Pass The Ticket)" groupRelation="and">                         <!-- Requesting a TGT on a remote system and retrieving it locally before requesting a service ticket with it. This is a Pass-The-Ticket attack because the TGT is obtained on the remote system, then used from a different machine (local). PsExec is used to execute commands on the remote system, and the "C$" admin share is used to retrieve the TGT, so the current user must have admin rights remotely and other PsExec prerequisites must be met. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">PsExec.exe;rubeus.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1110-001, Brute Force: Password Guessing (Brute Force Credentials of single Active Directory domain user via LDAP against domain controller (NTLM or Kerberos))" groupRelation="and">             <!-- Attempt to brute force Active Directory domain user on a domain controller, via LDAP, with NTLM or Kerberos. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">::LoadWithPartialName</CommandLine>
                     </Rule>

                     <Rule name="T1110-001, Brute Force: Password Guessing (Brute Force Credentials of single Azure AD user)" groupRelation="and">             <!-- Attempt to brute force Azure AD user via AzureAD powershell module. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Import-Module -Name AzureAD</CommandLine>
                     </Rule>
                         
                     <Rule name="T1110-001, Brute Force: Password Guessing (Password Brute User using Kerbrute Tool)" groupRelation="and">                     <!-- Bruteforce a single user's password from a wordlist. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">kerbrute.exe bruteuser</CommandLine>
                     </Rule>

                     <Rule name="T1110-001, Brute Force: Password Guessing (ESXi - Brute Force Until Account Lockout)" groupRelation="and">                    <!-- An adversary may attempt to brute force the password of privilleged account for privilege escalation. In the process, the TA may lock the account, which can be used for detection. [Reference](https://news.sophos.com/en-us/2022/07/14/blackcat-ransomware-attacks-not-merely-a-byproduct-of-bad-luck/#:~:text=A%20ransomware%20group%20attacking%20large,internal%20systems%20after%20establishing%20a) -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">lockout_threshold</CommandLine>
                     </Rule>

                     <Rule name="T1110-002, Brute Force: Password Cracking (Password Cracking with Hashcat)" groupRelation="and">                              <!-- Hashcat.exe with provided SAM file from registry of Windows and Password list to crack against -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">hashcat.exe</CommandLine>
                     </Rule>

                     <Rule name="T1110-003, Brute Force: Password Spraying (Password Spray all Domain Users)" groupRelation="and">                             <!-- Password Spray all Domain Users -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">do @echo | set/p=.</CommandLine>
                     </Rule>    

                     <Rule name="T1110-003, Brute Force: Password Spraying (Password Spray (DomainPasswordSpray))" groupRelation="and">                        <!-- Domain password spray using the DomainPasswordSpray tool. It will try a single password against all users in the domain https://github.com/dafthack/DomainPasswordSpray -->  
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Invoke-DomainPasswordSpray</CommandLine>
                     </Rule>    

                     <Rule name="T1110-003, Brute Force: Password Spraying (Password Spray Invoke-DomainPasswordSpray Light)" groupRelation="and">                        <!-- Domain password spray using the same core method of the [DomainPasswordSpray tool](https://github.com/dafthack/DomainPasswordSpray)  but without all the extra code that makes the script get blocked by many AVs.  This atomic test will attempt a single password against all users in a password list at $env:Temp\usersdpsLight.txt. You can create this file manually or with the automated prereq_command. The prereq_command will limit the user list to 200 users by default to help you avoid massive account lockout. -->  
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">function Invoke-dpsLight</CommandLine>
                     </Rule>

                     <Rule name="T1110-003, Brute Force: Password Spraying (Password Spray Microsoft Online Accounts with MSOLSpray (Azure/O365))" groupRelation="and">                        <!-- Brute force a list of Microsoft Online (Azure/O365) users with a single password via the MSOLSpray Powershell module. -->  
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Invoke-MSOLSpray</CommandLine>
                     </Rule>

                     <Rule name="T1555, Credentials from Password Stores (Dump credentials from Windows Credential Manager With PowerShell [web Credentials])" groupRelation="and">
                         <OriginalFileName condition="is">csc.exe</OriginalFileName>
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Get-CredManCreds -Force</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555, Credentials from Password Stores (Enumerate credentials from Windows Credential Manager using vaultcmd.exe [Windows Credentials])" groupRelation="and">               <!-- Enumerate credentials stored in Windows Credentials vault of Windows Credential Manager using builtin utility vaultcmd.exe -->
                         <Image condition="contains">VaultCmd.exe</Image>
                         <CommandLine condition="contains">vaultcmd /listcreds:"Windows Credentials"</CommandLine>
                     </Rule>

                     <Rule name="T1555, Credentials from Password Stores (Enumerate credentials from Windows Credential Manager using vaultcmd.exe [Web Credentials]" groupRelation="and">               <!-- enumerate credentials stored in Windows Credentials vault of Windows Credential Manager using builtin utility vaultcmd.exe. -->
                         <Image condition="contains">VaultCmd.exe</Image>
                         <CommandLine condition="contains">vaultcmd /listcreds:"Web Credentials"</CommandLine>
                     </Rule>

                     <Rule name="T1555, Credentials from Password Stores (lazagne)" groupRelation="and">                  <!-- The [LaZagne project](https://github.com/AlessandroZ/LaZagne) is an open source application used to retrieve lots of passwords stored on a local computer.  Each software stores its passwords using different techniques (plaintext, APIs, custom algorithms, databases, etc.).  This tool has been developed for the purpose of finding these passwords for the most commonly-used software. -->   
                         <Image condition="contains">WinCreds.exe</Image>
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">lazagnemodule</ParentCommandLine>
                     </Rule>    

                     <Rule name="T1555, Credentials from Password Stores (Wifi Credentials)" groupRelation="and">                  <!-- Loot local Credentials - Wifi Credentials technique via function of WinPwn. -->   
                         <OriginalFileName condition="contains">netsh.exe</OriginalFileName>
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">wificreds -consoleoutput -noninteractive</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555, Credentials from Password Stores (Decrypt Teamviewer Passwords)" groupRelation="and">                  <!-- Loot local Credentials - Decrypt Teamviewer Passwords technique via function of WinPwn. -->   
                         <OriginalFileName condition="is">CONHOST.EXE</OriginalFileName>
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">decryptteamviewer -consoleoutput -noninteractive</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555, Credentials from Password Stores (Run Chrome-password Collector)" groupRelation="and">                 <!-- The Chrome-password collector, renamed accesschk.exe, will be executed, Successful execution will produce stdout message stating "Copying db ... passwordsDB DB Opened. statement prepare DB connection closed properly". Adapted from [MITRE ATTACK Evals](https://github.com/mitre-attack/attack-arsenal/blob/66650cebd33b9a1e180f7b31261da1789cdceb66/adversary_emulation/APT29/CALDERA_DIY/evals/data/abilities/credential-access/e7cab9bb-3e3a-4d93-99cc-3593c1dc8c6d.yml) -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">accesschk.exe</CommandLine>
                     </Rule>

                     <Rule name="T1555, Credentials from Password Stores (WinPwn - BrowserPwn)" groupRelation="and">                  <!-- Collect Browser credentials as well as the history via winpwn browserpwn function of WinPwn. -->   
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">browserpwn -consoleoutput -noninteractive</ParentCommandLine>
                     </Rule>    

                     <Rule name="T1555, Credentials from Password Stores (WinPwn - Loot local Credentials - mimi-kittenz)" groupRelation="and">                  <!-- Loot local Credentials - mimi-kittenz technique via function of WinPwn - Extend timeout to 600s. -->   
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">kittenz -consoleoutput -noninteractive</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555, Credentials from Password Stores (WinPwn - PowerSharpPack - Sharpweb for Browser Credentials)" groupRelation="and">                  <!-- PowerSharpPack - Sharpweb searching for Browser Credentials technique via function of WinPwn. -->   
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-Sharpweb -command</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555, Credentials from Password Stores (WebBrowserPassView - Credentials from Browser)" groupRelation="and">                  <!-- WebBrowserPassView to extract passwords from browsers on a Window system. WebBrowserPassView is an open source application used to retrieve passwords stored on a local computer. Recently noticed as a tool used in the BlackCat Ransomware. -->   
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">WebBrowserPassView.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555, Credentials from Password Stores (BrowserStealer (Chrome / Firefox / Microsoft Edge))" groupRelation="and">             <!-- [Github Repo](https://github.com/SaulBerrenson/BrowserStealer) Simple password/cookies stealer for chrome, edge, and gecko based browsers (30 listed working). This attack simulates stealing the data from the browser files and printing them to the command line. If using to test with Firefox, if the browser is x64 you need to use the x64 build. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">BrowserCollector.exe</CommandLine>
                     </Rule>

                      <Rule name="T1555, Credentials from Password Stores (Dump Chrome Login Data with esentutl)" groupRelation="and">             <!-- esentutl to dump encrypted credentials from Google Chrome's Login database. [Reference](https://actzero.ai/resources/blog/hygiene-tip-shut-down-attackers-harvesting-cached-browser-credentials/) -->
                         <OriginalFileName condition="is">esentutl.exe</OriginalFileName>
                         <CommandLine condition="contains">esentutl.exe</CommandLine>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                     </Rule>    

                     <Rule name="T1555, Credentials from Password Stores (WinPwn - Loot local Credentials - Invoke-WCMDump)" groupRelation="and">            <!-- Loot local Credentials - Invoke-WCMDump technique via function of WinPwn. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-WCMDump</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555-003, Credentials from Password Stores: Credentials from Web Browsers (Run Chrome-password Collector)" groupRelation="and">                   <!-- A modified sysinternals suite will be downloaded and staged. The Chrome-password collector, renamed accesschk.exe, Adapted from [MITRE ATTACK Evals](https://github.com/mitre-attack/attack-arsenal/blob/66650cebd33b9a1e180f7b31261da1789cdceb66/adversary_emulation/APT29/CALDERA_DIY/evals/data/abilities/credential-access/e7cab9bb-3e3a-4d93-99cc-3593c1dc8c6d.yml) -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">accesschk.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555-003, Credentials from Password Stores: Credentials from Web Browsers (LaZagne - Credentials from Browser)" groupRelation="and">                   <!-- [LaZagne](https://github.com/AlessandroZ/LaZagne) to extract passwords from browsers on the Windows operating system. LaZagne is an open source application used to retrieve passwords stored on a local computer. -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">LaZagne.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555-003, Credentials from Password Stores: Credentials from Web Browsers (Access to Chrome Login Data)" groupRelation="and">                   <!-- An adversary accessing encrypted credentials from Google Chrome Login database. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Google\Chrome\User Data\Default\Login Data</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555-003, Credentials from Password Stores: Credentials from Web Browsers (Access to Opera Login Data)" groupRelation="and">                   <!-- An adversary accessing encrypted credentials from Opera web browser's login database. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Opera Software\Opera Stable\Login Data</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555-003, Credentials from Password Stores: Credentials from Web Browsers (Access to Windows Firefox Login Data)" groupRelation="and">                   <!-- An adversary accessing encrypted credentials from firefox web browser's login database. more info in https://support.mozilla.org/en-US/kb/profiles-where-firefox-stores-user-data -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Mozilla\Firefox\Profiles</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555-003, Credentials from Password Stores: Credentials from Web Browsers (Access to Windows Edge Login Data)" groupRelation="and">                   <!-- An adversary accessing encrypted credentials from Edge web browser's login database. more info in https://www.forensicfocus.com/articles/chromium-based-microsoft-edge-from-a-forensic-point-of-view/ -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Microsoft\Edge\User Data\Default</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555-003, Credentials from Password Stores: Credentials from Web Browsers (WinPwn - BrowserPwn)" groupRelation="and">                   <!-- Collect Browser credentials as well as the history via winpwn browserpwn function of WinPwn. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">browserpwn</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555-003, Credentials from Password Stores: Credentials from Web Browsers (WinPwn - Loot local Credentials - mimi-kittenz)" groupRelation="and">                   <!-- Loot local Credentials - mimi-kittenz technique via function of WinPwn - Extend timeout to 600s -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">kittenz</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555-003, Credentials from Password Stores: Credentials from Web Browsers (WinPwn - PowerSharpPack - Sharpweb for Browser Credentials)" groupRelation="and">                   <!-- PowerSharpPack - Sharpweb searching for Browser Credentials technique via function of WinPwn -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-Sharpweb</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555-003, Credentials from Password Stores: Credentials from Web Browsers (WebBrowserPassView - Credentials from Browser)" groupRelation="and">                   <!-- WebBrowserPassView to extract passwords from browsers on a Window system. WebBrowserPassView is an open source application used to retrieve passwords stored on a local computer. Recently noticed as a tool used in the BlackCat Ransomware. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">WebBrowserPassView</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555-003, Credentials from Password Stores: Credentials from Web Browsers (BrowserStealer (Chrome / Firefox / Microsoft Edge))" groupRelation="and">                   <!-- [Github Repo](https://github.com/SaulBerrenson/BrowserStealer) Simple password/cookies stealer for chrome, edge, and gecko based browsers (30 listed working). This attack simulates stealing the data from the browser files and printing them to the command line. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">BrowserCollector.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555-003, Credentials from Password Stores: Credentials from Web Browsers (Dump Chrome Login Data with esentutl)" groupRelation="and">                   <!-- An adversary using esentutl to dump encrypted credentials from Google Chrome's Login database. [Reference](https://actzero.ai/resources/blog/hygiene-tip-shut-down-attackers-harvesting-cached-browser-credentials/) -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">esentutl.exe;Chrome</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555-004, Credentials from Password Stores: Windows Credential Manager (Access Saved Credentials via VaultCmd)" groupRelation="and">                   <!-- List credentials currently stored in Windows Credential Manager via the native Windows utility vaultcmd.exe Credential Manager stores credentials for signing into websites, applications, and/or devices that request authentication through NTLM or Kerberos https://blog.malwarebytes.com/101/2016/01/the-windows-vaults/ https://medium.com/threatpunter/detecting-adversary-tradecraft-with-image-load-event-logging-and-eql-8de93338c16 -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">vaultcmd /listcreds</ParentCommandLine>
                     </Rule>

                     <Rule name="T1555-004, Credentials from Password Stores: Credentials from Web Browsers (WinPwn - Loot local Credentials - Invoke-WCMDump)" groupRelation="and">                   <!-- Loot local Credentials - Invoke-WCMDump technique via function of WinPwn -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-WCMDump</ParentCommandLine>
                     </Rule>

                     <Rule name="T1056-001, Input Capture: Keylogging (PowerShell - Prompt User for Password)" groupRelation="and">                                    <!-- Prompt User for Password (Local Phishing) as seen in Stitch RAT. Upon execution, a window will appear for the user to enter their credentials. Reference: https://github.com/nathanlopez/Stitch/blob/master/PyLib/askpass.py -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">host.UI.PromptForCredential;Windows Security Update</ParentCommandLine>
                     </Rule>

                     <Rule name="T1056-001, Input Capture: Keylogging (Hook PowerShell TLS Encrypt/Decrypt Messages)" groupRelation="and">                                    <!-- Hooks functions in PowerShell to read TLS Communications -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">mavinject;/INJECTRUNNING</ParentCommandLine>
                     </Rule>
                     
                     <Rule name="T1003, OS Credential Dumping (Gsecdump)" groupRelation="and">                     <!-- Dump credentials from memory using Gsecdump. -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">gsecdump.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1003, OS Credential Dumping (Credential Dumping with NPPSpy)" groupRelation="and">                     <!-- Changes ProviderOrder Registry Key Parameter and creates Key for NPPSpy. NPPSpy Source: https://github.com/gtworek/PSBits/tree/master/PasswordStealing/NPPSpy -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">NPPSPY</ParentCommandLine>
                     </Rule>

                     <Rule name="T1003, OS Credential Dumping (Retrieve Microsoft IIS Service Account Credentials Using AppCmd (using list))" groupRelation="and">                     <!-- AppCmd.exe is a command line utility which is used for managing an IIS web server. The list command within the tool reveals the service account credentials configured for the webserver. An adversary may use these credentials for other malicious purposes. [Reference](https://twitter.com/0gtweet/status/1588815661085917186?cxt=HHwWhIDUyaDbzYwsAAAA) -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">appcmd.exe list</ParentCommandLine>
                     </Rule>

                     <Rule name="T1003, OS Credential Dumping (Dump Credential Manager using keymgr.dll and rundll32.exe)" groupRelation="and">                     <!-- executes the exported function `KRShowKeyMgr` located in `keymgr.dll` using `rundll32.exe`. It opens a window that allows to export stored Windows credentials from the credential manager to a file (`.crd` by default). The file can then be retrieved and imported on an attacker-controlled computer to list the credentials get the passwords. The only limitation is that it requires a CTRL+ALT+DELETE input from the attacker, which can be achieve multiple ways (e.g. a custom implant with remote control capabilities, enabling RDP, etc.). Reference: https://twitter.com/0gtweet/status/1415671356239216653 -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">keymgr;rundll32.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1003, OS Credential Dumping (Send NTLM Hash with RPC Test Connection)" groupRelation="and">                     <!-- RpcPing command can be used to send an RPC test connection to the target server (-s) and force the NTLM hash to be sent in the process.  Ref: https://twitter.com/vysecurity/status/974806438316072960 -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">rpcping</ParentCommandLine>
                     </Rule>

                     <Rule name="T1528, Steal Application Access Token (Azure - Dump All Azure Key Vaults with Microburst)" groupRelation="and">                       <!-- The names, locations, and contents of key vaults within an Azure account will be output to a file. See - https://www.netspi.com/blog/technical/cloud-penetration-testing/a-beginners-guide-to-gathering-azure-passwords/ -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Get-AzurePasswords</ParentCommandLine>
                     </Rule>

                     <Rule name="T1539, Steal Web Session Cookie (Steal Firefox Cookies (Windows))" groupRelation="and">                     <!-- Query Firefox's cookies.sqlite database to steal the cookie data contained within it, similar to Zloader/Zbot's cookie theft function.  Note: If Firefox is running, the process will be killed to ensure that the DB file isn't locked.  See https://www.malwarebytes.com/resources/files/2020/05/the-silent-night-zloader-zbot_final.pdf. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">cookies.sqlite;Firefox</ParentCommandLine>
                     </Rule>

                     <Rule name="T1539, Steal Web Session Cookie (Steal Chrome Cookies (Windows))" groupRelation="and">                     <!-- Query Chrome's SQLite database to steal the encrypted cookie data, designed to function similarly to Zloader/Zbot's cookie theft function.  Once an adversary obtains the encrypted cookie info, they could go on to decrypt the encrypted value, potentially allowing for session theft.  Note: If Chrome is running, the process will be killed to ensure that the DB file isn't locked.  See https://www.malwarebytes.com/resources/files/2020/05/the-silent-night-zloader-zbot_final.pdf. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">Cookies;Chrome</ParentCommandLine>
                     </Rule>

                     <Rule name="T1087, Account Discovery: Domain Account (Automated AD Recon (ADRecon))" groupRelation="and">                                                <!-- ADRecon extracts and combines information about an AD environement into a report. Upon execution, an Excel file with all of the data will be generated and its path will be displayed. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">ADRecon.ps1</CommandLine>
                     </Rule>

                     <Rule name="T1087, Account Discovery: Domain Account (Adfind -Listing password policy)" groupRelation="and">                                             <!-- Adfind tool can be used for reconnaissance in an Active directory environment. The example chosen illustrates adfind used to query the local password policy. reference- http://www.joeware.net/freetools/tools/adfind/, https://social.technet.microsoft.com/wiki/contents/articles/7535.adfind-command-examples.aspx -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">AdFind.exe</CommandLine>
                     </Rule>    

                     <Rule name="T1087, Account Discovery: Domain Account (Enumerate Active Directory for Unconstrained Delegation)" groupRelation="and">                    <!-- Attackers may attempt to query for computer objects with the UserAccountControl property 'TRUSTED_FOR_DELEGATION' (0x80000;524288) set More Information - https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html#when-the-stars-align-unconstrained-delegation-leads-to-rce Prerequisite: AD RSAT PowerShell module is needed and it must run under a domain user. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Get-ADObject -LDAPFilter</CommandLine>
                     </Rule>

                     <Rule name="T1087, Account Discovery: Domain Account (Get-DomainUser with PowerView)" groupRelation="and">                                              <!-- Utilizing PowerView, run Get-DomainUser to identify the domain users. Upon execution, Users within the domain will be listed. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Get-DomainUser -verbose</CommandLine>
                     </Rule>

                     <Rule name="T1087, Account Discovery: Domain Account (Kerbrute - userenum)" groupRelation="and">                                                        <!-- Enumerates active directory usernames using the userenum function of Kerbrute. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">kerbrute.exe userenum</CommandLine>
                     </Rule>

                     <Rule name="T1087, Account Discovery: Domain Account (Wevtutil - Discover NTLM Users Remote)" groupRelation="and">                                      <!-- This is done remotely via wmic and captures the event code 4776 from the domain controller and stores the ouput in C:\temp. [Reference](https://www.reliaquest.com/blog/socgholish-fakeupdates/) -->
                         <OriginalFileName condition="is">wmic.exe</OriginalFileName>
                         <CommandLine condition="contains">wevtutil epl Security</CommandLine>
                     </Rule>

                     <Rule name="T1217, Browser Bookmark Discovery (List Google Chrome / Opera Bookmarks on Windows with powershell)" groupRelation="and">                   <!-- Searches for Google Chrome's and Opera's Bookmarks file (on Windows distributions) that contains bookmarks. Upon execution, paths that contain bookmark files will be displayed. -->
                         <ParentImage condition="is">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">-Filter Bookmarks -Recurse</ParentCommandLine>
                     </Rule>

                     <Rule name="T1217, Browser Bookmark Discovery (List Google Chrome / Edge Chromium Bookmarks on Windows with command prompt)" groupRelation="and">                   <!-- Searches for Google Chromes's and Edge Chromium's Bookmarks file (on Windows distributions) that contains bookmarks. Upon execution, paths that contain bookmark files will be displayed. -->
                         <ParentImage condition="is">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">where /R;Bookmarks</ParentCommandLine>
                     </Rule>

                     <Rule name="T1217, Browser Bookmark Discovery (List Mozilla Firefox bookmarks on Windows with command prompt)" groupRelation="and">                   <!-- Searches for Mozilla Firefox bookmarks file (on Windows distributions) that contains bookmarks in a SQLITE database. Upon execution, paths that contain bookmark files will be displayed. -->
                         <ParentImage condition="is">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains all">where /R;places.sqlite</ParentCommandLine>
                     </Rule>

                     <Rule name="T1217, Browser Bookmark Discovery (List Internet Explorer Bookmarks using the command prompt)" groupRelation="and">                   <!-- List the bookmarks for Internet Explorer that are found in the Favorites folder. -->
                         <ParentImage condition="is">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">\Favorites</ParentCommandLine>
                     </Rule>
                     
                     <Rule name="T1580, Cloud Infrastructure Discovery (AWS - EC2 Security Group Enumeration)" groupRelation="and">                   <!-- Attacker's action to enumerate EC2 Security Groups in a compromised AWS environment. -->
                         <ParentImage condition="is">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">aws ec2 describe-security-groups</ParentCommandLine>
                     </Rule>

                     <Rule name="T1482, Domain Trust Discovery (Windows - Discover domain trusts with dsquery)" groupRelation="and">                         <!-- Uses the dsquery command to discover domain trusts. Requires the installation of dsquery via Windows RSAT or the Windows Server AD DS role. -->    
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">dsquery</CommandLine>
                     </Rule>

                     <Rule name="T1482, Domain Trust Discovery (Windows - Discover domain trusts with nltest)" groupRelation="and">                          <!-- Uses the nltest command to discover domain trusts. Requires the installation of nltest via Windows RSAT or the Windows Server AD DS role. This technique has been used by the Trickbot malware family. -->    
                         <OriginalFileName condition="is">nltestrk.exe</OriginalFileName>
                         <CommandLine condition="contains">nltest</CommandLine>
                     </Rule>    

                     <Rule name="T1482, Domain Trust Discovery (Powershell enumerate domains and forests)" groupRelation="and">                              <!-- Use powershell to enumerate AD information. Requires the installation of PowerShell AD admin cmdlets via Windows RSAT or the Windows Server AD DS role. -->    
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Get-NetDomainTrust</CommandLine>
                     </Rule>

                     <Rule name="T1482, Domain Trust Discovery (Adfind - Enumerate Active Directory OUs)" groupRelation="and">                               <!-- Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory OUs reference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">AdFind.exe</CommandLine>
                     </Rule>

                     <Rule name="T1482, Domain Trust Discovery (Get-DomainTrust with PowerView)" groupRelation="and">                                        <!-- Utilizing PowerView, run Get-DomainTrust to identify domain trusts. Upon execution, progress and info about trusts within the domain being scanned will be displayed. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Get-DomainTrust</CommandLine>
                     </Rule>    

                     <Rule name="T1482, Domain Trust Discovery (Get-ForestTrust with PowerView)" groupRelation="and">                                        <!-- Utilizing PowerView, run Get-ForestTrust to identify forest trusts. Upon execution, progress and info about forest trusts within the domain being scanned will be displayed. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Get-ForestTrust</CommandLine>
                     </Rule>

                     <Rule name="T1482, Domain Trust Discovery (TruffleSnout - Listing AD Infrastructure)" groupRelation="and">                              <!-- Iterative AD discovery toolkit for offensive operators. Situational awareness and targeted low noise enumeration. Preference for OpSec.- https://github.com/dsnezhkov/TruffleSnout. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">TruffleSnout.exe</CommandLine>
                     </Rule>

                     <Rule name="T1083, File and Directory Discovery (File and Directory Discovery (cmd.exe))" groupRelation="and">                                          <!-- Find or discover files on the file system.  Upon successful execution, this test will output the results of all the data discovery commands to a specified file. -->     
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">dir /s</CommandLine>
                     </Rule>

                     <Rule name="T1083, File and Directory Discovery (File and Directory Discovery (PowerShell))" groupRelation="and">                                       <!-- Find or discover files on the file system. Upon execution, file and folder information will be displayed. -->     
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">ls -recurse</CommandLine>
                     </Rule>    

                     <Rule name="T1083, File and Directory Discovery (Launch DirLister Executable)" groupRelation="and">                                                     <!-- Launches the DirLister executable for a short period of time and then exits. Recently seen used by [BlackCat ransomware](https://news.sophos.com/en-us/2022/07/14/blackcat-ransomware-attacks-not-merely-a-byproduct-of-bad-luck/) to create a list of accessible directories and files. -->     
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">DirLister.exe</CommandLine>
                     </Rule>

                     <Rule name="T1083, File and Directory Discovery (Network Share Discovery PowerShell)" groupRelation="and">                                              <!-- Network Share Discovery utilizing PowerShell. The computer name variable may need to be modified to point to a different host Upon execution, avalaible network shares will be displayed in the powershell session. -->     
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">get-smbshare</CommandLine>
                     </Rule>
 
                     <Rule name="T1083, File and Directory Discovery (WinPwn - shareenumeration)" groupRelation="and">                                                       <!-- Network share enumeration using the shareenumeration function of WinPwn. -->     
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">shareenumeration</CommandLine>
                     </Rule>

                     <Rule name="T1083, File and Directory Discovery (Enumerate All Network Shares with SharpShares)" groupRelation="and">                                   <!-- SharpShares is a command line tool that can be integrated with Cobalt Strike's execute-assembly module, allowing for the enumeration of network shares.  This technique has been utilized by various ransomware groups, including BianLian. [Reference](https://www.cisa.gov/news-events/cybersecurity-advisories/aa23-136a) -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">SharpShares.exe</CommandLine>
                     </Rule>

                     <Rule name="T1083, File and Directory Discovery (Enumerate All Network Shares with Snaffler)" groupRelation="and">                                      <!-- Snaffler is an open-source tool that has been used by various threat groups, including Scattered Spider/Muddled Libra, to enumerate accessible shares and credential-containing files within a domain.  [Reference](https://unit42.paloaltonetworks.com/muddled-libra/) -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">Snaffler.exe</CommandLine>
                     </Rule>

                     <Rule name="T1654, Log Enumeration (Get-EventLog To Enumerate Windows Security Log)" groupRelation="and">                                      <!-- Uses the built-in PowerShell commandlet Get-EventLog to search for 'SYSTEM' keyword and saves results to a text file. This technique was observed in a [TheDFIRReport case](https://thedfirreport.com/2023/04/03/malicious-iso-file-leads-to-domain-wide-ransomware/)  where the threat actor enumerated the Windows Security audit log to determine user accounts and associated IPv4 addresses. Successful execution will save matching log events to the users temp folder. -->
                         <ParentImage condition="is">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">get-eventlog security</ParentCommandLine>
                     </Rule>

                     <Rule name="T1046, Network Service Discovery (Port Scan NMap for Windows)" groupRelation="and">                                         <!-- Scan ports to check for listening ports. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">nmap</CommandLine>
                     </Rule>

                     <Rule name="T1046, Network Service Discovery (Port Scan using python)" groupRelation="and">                                             <!-- Scan ports to check for listening ports with python. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains all">python; -i</CommandLine>
                     </Rule>    
 
                     <Rule name="T1046, Network Service Discovery (WinPwn - spoolvulnscan)" groupRelation="and">                                             <!-- Start MS-RPRN RPC Service Scan using spoolvulnscan function of WinPwn. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">spoolvulnscan</CommandLine>
                     </Rule>

                     <Rule name="T1046, Network Service Discovery (WinPwn - MS17-10)" groupRelation="and">                                                   <!-- Search for MS17-10 vulnerable Windows Servers in the domain using powerSQL function of WinPwn. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">MS17-10</CommandLine>
                     </Rule>

                     <Rule name="T1046, Network Service Discovery (WinPwn - bluekeep)" groupRelation="and">                                                  <!-- Search for bluekeep vulnerable Windows Systems in the domain using bluekeep function of WinPwn. Can take many minutes to complete (~600 seconds in testing on a small domain). -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">bluekeep</CommandLine>
                     </Rule>

                     <Rule name="T1046, Network Service Discovery (WinPwn - fruit)" groupRelation="and">                                                     <!-- Search for potentially vulnerable web apps (low hanging fruits) using fruit function of WinPwn. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">fruit -noninteractive -consoleoutput</CommandLine>
                     </Rule>

                     <Rule name="T1046, Network Service Discovery (Port-Scanning /24 Subnet with PowerShell)" groupRelation="and">                           <!-- Scanning common ports in a /24 subnet. If no IP address for the target subnet is specified the test tries to determine the attacking machine's "primary" IPv4 address first and then scans that address with a /24 netmask. The connection attempts to use a timeout parameter in milliseconds to speed up the scan. Please note the atomic might not print any output until the scans are completed. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Get-NetIPAddress -AddressFamily IPv4</CommandLine>
                     </Rule>

                     <Rule name="T1135, Network Share Discovery (Network Share Discovery PowerShell)" groupRelation="and">                                  <!-- Network Share Discovery utilizing PowerShell. The computer name variable may need to be modified to point to a different host Upon execution, avalaible network shares will be displayed in the powershell session -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">get-smbshare</CommandLine>
                     </Rule>
                     
                     <Rule name="T1135, Network Share Discovery (View available share drives)" groupRelation="and">                                         <!-- View information about all of the resources that are shared on the local computer Upon execution, avalaible share drives will be displayed in the powershell session. -->   
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">net share</ParentCommandLine>
                     </Rule>

                     <Rule name="T1135, Network Share Discovery (Share Discovery with PowerView)" groupRelation="and">                                         <!-- View information about all of the resources that are shared on the local computer Upon execution, avalaible share drives will be displayed in the powershell session. -->   
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">PowerView;Find-DomainShare -CheckShareAccess</ParentCommandLine>
                     </Rule>

                     <Rule name="T1135, Network Share Discovery (PowerView ShareFinder)" groupRelation="and">                                  <!-- PowerView is a PowerShell tool to gain network situational awareness on Windows domains. ShareFinder finds (non-standard) shares on machines in the domain. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Invoke-ShareFinder</CommandLine>
                     </Rule>

                     <Rule name="T1135, Network Share Discovery (WinPwn - shareenumeration)" groupRelation="and">                                         <!-- Network share enumeration using the shareenumeration function of WinPwn. -->   
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">shareenumeration</ParentCommandLine>
                     </Rule>

                     <Rule name="T1135, Network Share Discovery (Enumerate All Network Shares with SharpShares)" groupRelation="and">                                         <!-- SharpShares is a command line tool that can be integrated with Cobalt Strike's execute-assembly module, allowing for the enumeration of network shares.  This technique has been utilized by various ransomware groups, including BianLian. [Reference](https://www.cisa.gov/news-events/cybersecurity-advisories/aa23-136a) -->   
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">SharpShares.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1135, Network Share Discovery (Enumerate All Network Shares with Snaffler)" groupRelation="and">                     <!-- Snaffler is an open-source tool that has been used by various threat groups, including Scattered Spider/Muddled Libra, to enumerate accessible shares and credential-containing files within a domain.  [Reference](https://unit42.paloaltonetworks.com/muddled-libra/) -->
                         <OriginalFileName condition="contains">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Snaffler.exe</CommandLine>
                     </Rule>

                     <Rule name="T1120, Peripheral Device Discovery (Win32_PnPEntity Hardware Inventory)" groupRelation="and">                     <!-- Perform peripheral device discovery using Get-WMIObject Win32_PnPEntity. -->
                         <OriginalFileName condition="contains">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Win32_PnPEntity</CommandLine>
                     </Rule>

                     <Rule name="T1120, Peripheral Device Discovery (WinPwn - printercheck)" groupRelation="and">                     <!-- Search for printers / potential vulns using printercheck function of WinPwn. -->
                         <OriginalFileName condition="contains">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">printercheck</CommandLine>
                     </Rule>

                     <Rule name="T1120, Peripheral Device Discovery (Peripheral Device Discovery via fsutil)" groupRelation="and">                     <!-- Performs pheripheral device discovery utilizing fsutil to list all drives. -->
                         <OriginalFileName condition="contains">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">fsutil fsinfo</CommandLine>
                     </Rule>

                     <Rule name="T1069-001, Permission Groups Discovery: Local Groups (Permission Groups Discovery PowerShell (Local))" groupRelation="and">                 <!-- Permission Groups Discovery utilizing PowerShell. This test will display some errors if run on a computer not connected to a domain. Upon execution, domain information will be displayed. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Get-LocalGroupMember -Name</CommandLine>
                     </Rule>

                     <Rule name="T1069-001, Permission Groups Discovery: Local Groups (SharpHound3 - LocalAdmin)" groupRelation="and">                                       <!-- This module runs the Windows executable of SharpHound in order to remotely list members of the local Administrators group (SAMR) -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">SharpHound.exe</CommandLine>
                     </Rule> 

                     <Rule name="T1069-001, Permission Groups Discovery: Local Groups (Wmic Group Discovery)" groupRelation="and">                                           <!-- Utilizing wmic.exe to enumerate groups on the local system. Upon execution, information will be displayed of local groups on system. -->
                         <OriginalFileName condition="is">wmic.exe</OriginalFileName>
                         <CommandLine condition="contains">wmic group get name</CommandLine>
                     </Rule>

                     <Rule name="T1069-002, Permission Groups Discovery: Domain Groups (Permission Groups Discovery PowerShell (Domain))" groupRelation="and">               <!-- Permission Groups Discovery utilizing PowerShell. This test will display some errors if run on a computer not connected to a domain. Upon execution, domain information will be displayed. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">get-ADPrincipalGroupMembership</CommandLine>
                     </Rule>

                     <Rule name="T1069-002, Permission Groups Discovery: Domain Groups (Enumerate Users Not Requiring Pre Auth (ASRepRoast))" groupRelation="and">           <!-- When successful, accounts that do not require kerberos pre-auth will be returned. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Get-ADUser</CommandLine>
                     </Rule>

                     <Rule name="T1069-002, Permission Groups Discovery: Domain Groups (Enumerate Active Directory Groups with Get-AdGroup)" groupRelation="and">           <!-- Upon successful execution a listing of groups will output with their paths in AD. Reference: https://docs.microsoft.com/en-us/powershell/module/activedirectory/get-adgroup?view=windowsserver2022-ps -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Get-AdGroup</CommandLine>
                     </Rule>

                     <Rule name="T1069-002, Permission Groups Discovery: Domain Groups (Active Directory Enumeration with LDIFDE)" groupRelation="and">                     <!-- Output information from Active Directory to a specified file. [Ldifde](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc731033(v=ws.11)) is a CLI tool for creating, modifying and deleting directory objects. The test is derived from the CISA Report on Voly Typhoon. Reference: https://media.defense.gov/2023/May/24/2003229517/-1/-1/0/CSA_Living_off_the_Land.PDF -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">ldifde.exe</CommandLine>
                     </Rule>

                     <Rule name="T1057, Process Discovery (Process Discovery - tasklist)" groupRelation="and">                                <!-- Utilize tasklist to identify processes. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">tasklist</CommandLine>
                     </Rule>

                     <Rule name="T1057, Process Discovery (Process Discovery - Get-Process)" groupRelation="and">                                <!-- Utilize Get-Process PowerShell cmdlet to identify processes. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Get-Process</CommandLine>
                     </Rule>    

                     <Rule name="T1057, Process Discovery (Process Discovery - get-wmiObject)" groupRelation="and">                         <!-- Utilize get-wmiObject PowerShell cmdlet to identify processes. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">get-wmiObject</ParentCommandLine>
                     </Rule>

                     <Rule name="T1057, Process Discovery (Process Discovery - wmic process)" groupRelation="and">                         <!-- Utilize windows management instrumentation to identify processes. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">wmic process</CommandLine>
                     </Rule>

                     <Rule name="T1057, Process Discovery (Process Discovery - Process Hacker)" groupRelation="and">                                <!-- Process Hacker can be exploited to infiltrate system processes, identify weak points, or achieve unauthorized control over systems. However, its malicious use can often be flagged by security defenses, rendering it a perilous tool for illegitimate purposes. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">ProcessHacker.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1012, Query Registry (Query Registry)" groupRelation="and">                                      <!-- Query Windows Registry. cmd.exe will perform multiple reg queries. Some will succeed and others will fail (dependent upon OS). References: https://blog.cylance.com/windows-registry-persistence-part-2-the-run-keys-and-search-order https://blog.cylance.com/windows-registry-persistence-part-1-introduction-attack-phases-and-windows-services http://www.handgrep.se/repository/cheatsheets/postexploitation/WindowsPost-Exploitation.pdf https://www.offensive-security.com/wp-content/uploads/2015/04/wp.Registry_Quick_Find_Chart.en_us.pdf -->    
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">reg query</ParentCommandLine>
                     </Rule>

                     <Rule name="T1018, Remote System Discovery (Remote System Discovery - net)" groupRelation="and">                                        <!-- Upon successful execution, cmd.exe will execute `net.exe view` and display results of local systems on the network that have file and print sharing enabled. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">net view</CommandLine>
                     </Rule>

                     <Rule name="T1018, Remote System Discovery (Remote System Discovery - ping sweep)" groupRelation="and">                                 <!-- Upon successful execution, cmd.exe will perform a for loop against the 192.168.1.1/24 network. Output will be via stdout. -->
                         <OriginalFileName condition="is">ping.exe</OriginalFileName>
                         <CommandLine condition="contains"> ping -n 1 -w 100 </CommandLine>
                     </Rule>

                     <Rule name="T1018, Remote System Discovery (Remote System Discovery - arp)" groupRelation="and">                                        <!-- Upon successful execution, cmd.exe will execute arp to list out the arp cache. Output will be via stdout. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">arp -a</CommandLine>
                     </Rule>

                     <Rule name="T1018, Remote System Discovery (Remote System Discovery - adidnsdump)" groupRelation="and">                                <!-- This tool enables enumeration and exporting of all DNS records in the zone for recon purposes of internal networks Python 3 and adidnsdump must be installed. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">adidnsdump</CommandLine>
                     </Rule>    

                     <Rule name="T1018, Remote System Discovery (Enumerate domain computers within Active Directory using DirectorySearcher)" groupRelation="and">                                <!-- A Powershell script that enumerates Active Directory to determine computers that are joined to the domain. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">System.DirectoryServices.DirectorySearcher</CommandLine>
                     </Rule>

                     <Rule name="T1018, Remote System Discovery (Enumerate Active Directory Computers with Get-AdComputer)" groupRelation="and">                                <!-- Enumerate Computers within Active Directory. Upon successful execution a listing of Computers will output with their paths in AD. Reference: https://github.com/MicrosoftDocs/windows-powershell-docs/blob/main/docset/winserver2022-ps/activedirectory/Get-ADComputer.md -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Get-AdComputer</CommandLine>
                     </Rule>

                     <Rule name="T1018, Remote System Discovery (Enumerate Active Directory Computers with ADSISearcher)" groupRelation="and">                                  <!-- Utilize ADSISearcher to enumerate computers within Active Directory. Upon successful execution a listing of computers will output with their paths in AD. Reference: https://devblogs.microsoft.com/scripting/use-the-powershell-adsisearcher-type-accelerator-to-search-active-directory/ -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">adsisearcher</CommandLine>
                     </Rule>

                     <Rule name="T1018, Remote System Discovery (Get-DomainController with PowerView)" groupRelation="and">                                                     <!-- Utilizing PowerView, run Get-DomainController to identify the Domain Controller. Upon execution, information about the domain controller within the domain will be displayed. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">PowerView</CommandLine>
                     </Rule>

                     <Rule name="T1018, Remote System Discovery (Get-WmiObject to Enumerate Domain Controllers)" groupRelation="and">                                           <!-- utilize get-wmiobject to enumerate Active Directory for Domain Controllers. Upon successful execution a listing of Systems from AD will output with their paths. Reference: https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-wmiobject?view=powershell-5.1 -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">get-wmiobject</CommandLine>
                     </Rule>

                     <Rule name="T1018, Remote System Discovery (Enumerate Remote Hosts with Netscan)" groupRelation="and">                                                     <!-- Netscan to identify remote hosts in a specified network range. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">netscan.exe</CommandLine>
                     </Rule>

                     <Rule name="T1082, System Information Discovery (Hostname Discovery (Windows))" groupRelation="and">                                                       <!-- Identify system hostname for Windows. Upon execution, the hostname of the device will be displayed. -->
                         <OriginalFileName condition="is">hostname.exe</OriginalFileName>
                         <CommandLine condition="contains">HOSTNAME.EXE</CommandLine>
                     </Rule>

                     <Rule name="T1082, System Information Discovery (Windows MachineGUID Discovery)" groupRelation="and">                                                      <!-- Identify the Windows MachineGUID value for a system. Upon execution, the machine GUID will be displayed from registry.Identify the Windows MachineGUID value for a system. Upon execution, the machine GUID will be displayed from registry. -->    
                         <OriginalFileName condition="is">reg.exe</OriginalFileName>
                         <CommandLine condition="contains">MachineGuid</CommandLine>
                     </Rule>     

                     <Rule name="T1082, System Information Discovery (Griffon Recon)" groupRelation="and">                                                     <!-- This script emulates the reconnaissance script seen in used by Griffon and was modified by security researcher Kirk Sayre  in order simply print the recon results to the screen as opposed to exfiltrating them. [Script](https://gist.github.com/kirk-sayre-work/7cb5bf4e2c7c77fa5684ddc17053f1e5).   For more information see also [https://malpedia.caad.fkie.fraunhofer.de/details/js.griffon](https://malpedia.caad.fkie.fraunhofer.de/details/js.griffon) and [https://attack.mitre.org/software/S0417/](https://attack.mitre.org/software/S0417/) -->    
                         <OriginalFileName condition="is">cscript.exe</OriginalFileName>
                         <CommandLine condition="contains">griffon</CommandLine>
                     </Rule>

                     <Rule name="T1082, System Information Discovery (WinPwn - winPEAS)" groupRelation="and">                                                  <!-- Discover Local Privilege Escalation possibilities using winPEAS function of WinPwn. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">winPEAS</ParentCommandLine>
                     </Rule>

                     <Rule name="T1082, System Information Discovery (WinPwn - itm4nprivesc)" groupRelation="and">                                             <!-- Discover Local Privilege Escalation possibilities using itm4nprivesc function of WinPwn. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">itm4nprivesc</CommandLine>
                     </Rule>

                     <Rule name="T1082, System Information Discovery (WinPwn - Powersploits privesc checks)" groupRelation="and">                              <!-- Powersploits privesc checks using oldchecks function of WinPwn. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">oldchecks</ParentCommandLine>
                     </Rule>    

                     <Rule name="T1082, System Information Discovery (WinPwn - General privesc checks)" groupRelation="and">                                   <!-- General privesc checks using the otherchecks function of WinPwn. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">otherchecks</ParentCommandLine>
                     </Rule>

                     <Rule name="T1082, System Information Discovery (WinPwn - GeneralRecon)" groupRelation="and">                                            <!-- Collect general computer informations via GeneralRecon function of WinPwn. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Generalrecon</ParentCommandLine>
                     </Rule>

                     <Rule name="T1082, System Information Discovery (WinPwn - Morerecon)" groupRelation="and">                                               <!-- Gathers local system information using the Morerecon function of WinPwn. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Morerecon</ParentCommandLine>
                     </Rule>

                     <Rule name="T1082, System Information Discovery (WinPwn - RBCD-Check)" groupRelation="and">                                              <!-- Search for Resource-Based Constrained Delegation attack paths using RBCD-Check function of WinPwn. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">RBCD-Check</ParentCommandLine>
                     </Rule>

                     <Rule name="T1082, System Information Discovery (PowerSharpPack - Watson searching for missing windows patches)" groupRelation="and">           <!-- PowerSharpPack - Watson searching for missing windows patches  technique via function of WinPwn. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Invoke-watson</CommandLine>
                     </Rule>

                     <Rule name="T1082, System Information Discovery (PowerSharpPack - Sharpup checking common Privesc vectors)" groupRelation="and">                <!-- PowerSharpPack - Sharpup checking common Privesc vectors technique via function of WinPwn - Takes several minutes to complete. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Invoke-SharpUp</CommandLine>
                     </Rule>

                     <Rule name="T1082, System Information Discovery (PowerSharpPack - Seatbelt)" groupRelation="and">                                               <!-- PowerSharpPack - Seatbelt technique via function of WinPwn. [Seatbelt](https://github.com/GhostPack/Seatbelt) is a C# project that performs a number of security oriented host-survey "safety checks" relevant from both offensive and defensive security perspectives. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Invoke-Seatbelt</CommandLine>
                     </Rule>

                     <Rule name="T1082, System Information Discovery (Azure Security Scan with SkyArk)" groupRelation="and">                                         <!-- Utilize a valid read-only Azure AD user's credentials to conduct a security scan and determine what users exist in a given tenant, as well as identify any admin users.  Once the test is complete, a folder will be output to the temp directory that contains 3 csv files which provide info on the discovered users.  See https://github.com/cyberark/SkyArk -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">AzureStealth</CommandLine>
                     </Rule>   

                     <Rule name="T1082, System Information Discovery (Driver Enumeration using DriverQuery)" groupRelation="and">                                    <!-- Executes the driverquery command to list drivers installed on the system. Adversaries utilize the feature to enumerate the driver and it can be used for Exploitation.  command /v - provide verbose output but not valid for signed drivers /si - provide information about signed drivers -->
                         <OriginalFileName condition="is">drvqry.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">driverquery</ParentCommandLine>
                     </Rule>

                     <Rule name="T1082, System Information Discovery (BIOS Information Discovery through Registry)" groupRelation="and">                             <!-- Looks up for BIOS information in the registry. BIOS information is often read in order to detect sandboxing environments.  Upon execution, BIOS information will be displayed. - https://tria.ge/210111-eaz8mqhgh6/behavioral1 - https://evasions.checkpoint.com/techniques/registry.html -->
                         <OriginalFileName condition="contains">cmd.exe</OriginalFileName>
                         <ParentCommandLine condition="contains">SystemBiosVersion</ParentCommandLine>
                     </Rule>

                     <Rule name="T1016, System Network Configuration Discovery (System Network Configuration Discovery on Windows)" groupRelation="and">                    <!-- Identify network configuration information Upon successful execution, cmd.exe will spawn multiple commands to list network configuration settings. Output will be via stdout. --> 
                         <OriginalFileName condition="is">nbtinfo.exe</OriginalFileName>
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">netsh interface show interface</ParentCommandLine>
                     </Rule>

                     <Rule name="T1016, System Network Configuration Discovery (List Windows Firewall Rules)" groupRelation="and">                                          <!-- Enumerates Windows Firewall Rules using netsh. Upon successful execution, cmd.exe will spawn netsh.exe to list firewall rules. Output will be via stdout. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">netsh advfirewall</CommandLine>
                     </Rule>

                     <Rule name="T1016, System Network Configuration Discovery (List Open Egress Ports)" groupRelation="and">                                               <!-- The technique used was taken from the following blog: https://www.blackhillsinfosec.com/poking-holes-in-the-firewall-egress-testing-with-allports-exposed/ Upon successful execution, powershell will read top-128.txt (ports) and contact each port to confirm if open or not. Output will be to Desktop\open-ports.txt. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">$ports = Get-content</CommandLine>
                     </Rule>    

                     <Rule name="T1016, System Network Configuration Discovery (Enumerate Stored Wi-Fi Profiles And Passwords via netsh)" groupRelation="and">              <!-- information about previously connected Wi-Fi networks will be displayed with their corresponding key (if present). -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">netsh wlan</CommandLine>
                     </Rule>

                     <Rule name="T1016-002, System Network Configuration Discovery: Wi-Fi Discovery (Enumerate Stored Wi-Fi Profiles And Passwords via netsh)" groupRelation="and">                    <!-- Information about previously connected Wi-Fi networks will be displayed with their corresponding key (if present). -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">netsh wlan</CommandLine>
                     </Rule>

                     <Rule name="T1049, System Network Connections Discovery (System Discovery using SharpView)" groupRelation="and">                                       <!-- Get a listing of network connections, domains, domain users, and etc.   sharpview.exe located in the bin folder, an opensource red-team tool. Upon successful execution, cmd.exe will execute sharpview.exe <method>. Results will output via stdout. --> 
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">SharpView.exe</CommandLine>
                     </Rule>

                     <Rule name="T1033, System Owner/User Discovery (User Discovery With Env Vars PowerShell Script)" groupRelation="and">                           <!-- Use the PowerShell environment variables to identify the current logged user. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">[System.Environment]::UserName</CommandLine>
                     </Rule>

                     <Rule name="T1033, System Owner/User Discovery (GetCurrent User with PowerShell Script)" groupRelation="and">                                   <!-- Use the PowerShell "GetCurrent" method of the WindowsIdentity .NET class to identify the logged user. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">[System.Security.Principal.WindowsIdentity]::GetCurrent</CommandLine>
                     </Rule>

                     <Rule name="T1007, System Service Discovery (System Service Discovery)" groupRelation="and">                                   <!-- Identify system services. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">sc query</CommandLine>
                     </Rule>

                     <Rule name="T1570, Lateral Tool Transfer (Exfiltration Over SMB over QUIC (New-SmbMapping))" groupRelation="and">                                      <!-- An attacker exfiltrating data over SMB over QUIC using the New-SmbMapping command. Prerequisites:   - A file server running Windows Server 2022 Datacenter: Azure Edition   - A Windows 11 computer   - Windows Admin Center -->   
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">New-SmbMapping</CommandLine>
                     </Rule>

                     <Rule name="T1570, Lateral Tool Transfer (Exfiltration Over SMB over QUIC (NET USE))" groupRelation="and">                                             <!--  an attacker exfiltrating data over SMB over QUIC using the NET USE command. Prerequisites:   - A file server running Windows Server 2022 Datacenter: Azure Edition   - A Windows 11 computer   - Windows Admin Center -->   
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">TRANSPORT:QUIC</CommandLine>
                     </Rule>

                     <Rule name="T1560, Archive Collected Data (Compress Data for Exfiltration With PowerShell)" groupRelation="and">                                <!-- An adversary may compress data (e.g., sensitive documents) that is collected prior to exfiltration. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains all">-Recurse ; Compress-Archive</CommandLine>
                     </Rule>

                     <Rule name="T1560, Archive Collected Data: Archive via Utility (Compress Data for Exfiltration With Rar)" groupRelation="and">                 <!-- An adversary may compress data (e.g., sensitive documents) that is collected prior to exfiltration. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">Rar.exe a -r</CommandLine>
                     </Rule>

                     <Rule name="T1560, Archive Collected Data: Archive via Utility (Compress Data and lock with password for Exfiltration with winzip)" groupRelation="and">                 <!-- An adversary may compress data (e.g., sensitive documents) that is collected prior to exfiltration. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">winzip64.exe</CommandLine>
                     </Rule>
                     
                     <Rule name="T1560, Archive Collected Data: Archive via Utility (Compress Data and lock with password for Exfiltration with winrar)" groupRelation="and">                 <!-- An adversary may compress data (e.g., sensitive documents) that is collected prior to exfiltration. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">winrar.exe</CommandLine>
                     </Rule>

                     <Rule name="T1560, Archive Collected Data: Archive via Utility (ESXi - Remove Syslog remote IP)" groupRelation="and">                                                    <!-- An adversary may compress data (e.g., sensitive documents) that is collected prior to exfiltration. -->
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">7z.exe</CommandLine>
                     </Rule>

                     <Rule name="T1560, Archive Collected Data: Archive via Utility (Compress Data and lock with password for Exfiltration with 7zip)" groupRelation="and">                   <!-- An adversary may edit the syslog config to remove the loghost in order to prevent or redirect logs being received by SIEM. -->
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">plink.exe -ssh</CommandLine>
                     </Rule>

                     <Rule name="T1560-001, Archive Collected Data: Archive via Utility (Compress Data for Exfiltration With Rar)" groupRelation="and">                <!-- An adversary may compress data (e.g., sensitive documents) that is collected prior to exfiltration. -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">Rar.exe a -r</ParentCommandLine>
                     </Rule>

                     <Rule name="T1119, Automated Collection (Automated Collection Command Prompt)" groupRelation="and">                               <!-- Automated Collection. Upon execution, check the users temp directory (%temp%) --> 
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">mkdir %temp</ParentCommandLine>
                     </Rule>

                     <Rule name="T1119, Automated Collection (Automated Collection PowerShell)" groupRelation="and">                                   <!-- Automated Collection. Upon execution, check the users temp directory (%temp%) -->     
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">New-Item -Path $env:TEMP</CommandLine>
                     </Rule>

                     <Rule name="T1119, Automated Collection (Recon information for export with Command Prompt)" groupRelation="and">                  <!-- Collect information for exfiltration. Upon execution, check the users temp directory (%temp%) --> 
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">sc query type=service</ParentCommandLine>
                     </Rule>

                     <Rule name="T1115, Clipboard Data (Utilize Clipboard to store or execute commands from)" groupRelation="and">                    <!-- Add data to clipboard to copy off or execute commands from. -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">dir | clip</ParentCommandLine>
                     </Rule>

                     <Rule name="T1115, Clipboard Data (Execute Commands from Clipboard using PowerShell)" groupRelation="and">                    <!-- Utilize PowerShell to echo a command to clipboard and execute it. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Get-Clipboard | iex</ParentCommandLine>
                     </Rule>

                     <Rule name="T1115, Clipboard Data (Collect Clipboard Data via VBA)" groupRelation="and">                    <!-- Copies the data stored in the user's clipboard and writes it to a file. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Set-Clipboard</ParentCommandLine>
                     </Rule>

                     <Rule name="T1530, Data from Cloud Storage Object (Azure - Enumerate Azure Blobs with MicroBurst)" groupRelation="and">                    <!-- Utilize a wordlist to enumerate the public facing containers and blobs of a specified Azure storage account.  See https://www.netspi.com/blog/technical/cloud-penetration-testing/anonymously-enumerating-azure-file-resources/ .  -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Invoke-EnumerateAzureBlobs</ParentCommandLine>
                     </Rule>

                     <Rule name="T1005, Data from Local System (Search files of interest and save them to a single zip file (Windows))" groupRelation="and">                  <!-- Searches for files of certain extensions and saves them to a single zip file prior to extraction. -->
                         <OriginalFileName condition="is">Powershell.EXE</OriginalFileName>
                         <CommandLine condition="contains all">$startingDirectory; $outputZip</CommandLine>
                     </Rule>
  
                     <Rule name="T1039, Data from Network Shared Drive (Copy a sensitive File over Administrative share with copy)" groupRelation="and">                     <!-- Copy from sensitive File from the c$ of another LAN computer with copy cmd https://twitter.com/SBousseaden/status/1211636381086339073 -->
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">copy</ParentCommandLine>
                     </Rule>

                     <Rule name="T1039, Data from Network Shared Drive (Copy a sensitive File over Administrative share with Powershell)" groupRelation="and">                     <!-- Copy from sensitive File from the c$ of another LAN computer with powershell https://twitter.com/SBousseaden/status/1211636381086339073 -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">copy-item</ParentCommandLine>
                     </Rule>

                     <Rule name="T1074-001, Data Staged: Local Data Staging (Stage data from Discovery.bat)" groupRelation="and">                              <!-- Utilize powershell to download discovery.bat and save to a local file. an attacker downloading data collection tools onto the host. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Discovery.bat</ParentCommandLine>
                     </Rule>

                     <Rule name="T1074-001, Data Staged: Local Data Staging (Zip a Folder with PowerShell for Staging in Temp)" groupRelation="and">                              <!--  Use living off the land tools to zip a file and stage it in the Windows temporary folder for later exfiltration. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Compress-Archive</ParentCommandLine>
                     </Rule>

                     <Rule name="T1056-001, Input Capture: Keylogging (PowerShell - Prompt User for Password)" groupRelation="and">                                    <!-- Prompt User for Password (Local Phishing) as seen in Stitch RAT. Upon execution, a window will appear for the user to enter their credentials. Reference: https://github.com/nathanlopez/Stitch/blob/master/PyLib/askpass.py -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">host.UI.PromptForCredential;Windows Security Update</ParentCommandLine>
                     </Rule>

                     <Rule name="T1056-001, Input Capture: Keylogging (Hook PowerShell TLS Encrypt/Decrypt Messages)" groupRelation="and">                                    <!-- Hooks functions in PowerShell to read TLS Communications -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">mavinject;/INJECTRUNNING</ParentCommandLine>
                     </Rule>

                     <Rule name="T1113, Screen Capture  (Windows Screencapture)" groupRelation="and">                                                                       <!-- Use Psr.exe binary to collect screenshots of user display. -->   
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">psr.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1113, Screen Capture  (Windows Screencapture)" groupRelation="and">                                                                       <!-- Take a screen capture of the desktop through a call to the [Graphics.CopyFromScreen] .NET API. [Graphics.CopyFromScreen]: https://docs.microsoft.com/en-us/dotnet/api/system.drawing.graphics.copyfromscreen -->   
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">CopyFromScreen</ParentCommandLine>
                     </Rule>

                     <Rule name="T1573, Encrypted Channel (OpenSSL C2)" groupRelation="and">                          <!-- Thanks to @OrOneEqualsOne for this quick C2 method. This is to test to see if a C2 session can be established using an SSL socket. More information about this technique, including how to set up the listener, can be found here: https://medium.com/walmartlabs/openssl-server-reverse-shell-from-windows-client-aee2dbfa0926 -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">server_ip;server_port;socket</ParentCommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (certutil download (urlcache))" groupRelation="and">                                                          <!-- Use certutil -urlcache argument to download a file from the web. Note - /urlcache also works! -->
                         <OriginalFileName condition="is">CertUtil.exe</OriginalFileName>
                         <CommandLine condition="contains">certutil -urlcache</CommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (certutil download (verifyctl))" groupRelation="and">                                                         <!-- Use certutil -verifyctl argument to download a file from the web. Note - /verifyctl also works! -->
                         <OriginalFileName condition="is">CertUtil.exe</OriginalFileName>
                         <CommandLine condition="contains">certutil -verifyctl</CommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (certutil download (verifyctl))" groupRelation="and">                                                         <!-- uses BITSAdmin.exe to schedule a BITS job for the download of a file. This technique is used by Qbot malware to download payloads. -->
                         <OriginalFileName condition="is">bitsadmin.exe</OriginalFileName>
                         <CommandLine condition="contains">bitsadmin.exe /transfer</CommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (Windows - PowerShell Download)" groupRelation="and">                                                         <!-- Uses PowerShell to download a payload. This technique is used by multiple adversaries and malware families. -->   
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">DownloadFile</CommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (OSTAP Worming Activity)" groupRelation="and">                                                                <!-- OSTap copies itself in a specfic way to shares and secondary drives. -->
                         <OriginalFileName condition="is">cscript.exe</OriginalFileName>
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">echo var fileObject = WScript.createobject</ParentCommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (Download a File with Windows Defender MpCmdRun.exe)" groupRelation="and">                                    <!-- Uses Windows Defender MpCmdRun.exe to download a file from the internet (must have version 4.18 installed). The input arguments "remote_file" and "local_path" can be used to specify the download URL and the name of the output file. -->   
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">MpCmdRun.exe -DownloadFile</CommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (File Download via PowerShell)" groupRelation="and">                                    <!-- Use PowerShell to download and write an arbitrary file from the internet. Example is from the 2021 Threat Detection Report by Red Canary. -->     
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">DownloadString</ParentCommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (File download with finger.exe on Windows)" groupRelation="and">                        <!-- File download using finger.exe. Connect to localhost by default, use custom input argument to test finger connecting to an external server. Because this is being tested on the localhost, you should not be expecting a successful connection https://www.exploit-db.com/exploits/48815 https://www.bleepingcomputer.com/news/security/windows-10-finger-command-can-be-abused-to-download-or-steal-files/ -->
                         <OriginalFileName condition="is">finger.exe</OriginalFileName>
                         <CommandLine condition="contains">finger</CommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (Download a file with IMEWDBLD.exe)" groupRelation="and">                               <!-- Use IMEWDBLD.exe (built-in to windows) to download a file. -->
                         <OriginalFileName condition="is">PowerShell.exe</OriginalFileName>
                         <CommandLine condition="contains">IMEWDBLD.exe</CommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (Curl Download File)" groupRelation="and">                                              <!-- Utilizes native curl.exe, or downloads it if not installed, to download a remote DLL and output to a number of directories to simulate malicious behavior. Expected output will include whether the file downloaded successfully or not. --> 
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">curl.exe -k</ParentCommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (Curl Download File)" groupRelation="and">                                              <!-- Utilizes native curl.exe, or downloads it if not installed, to upload a txt file to simulate data exfiltration Expected output will include whether the file uploaded successfully or not. --> 
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">curl.exe --upload-file</ParentCommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (Lolbas replace.exe use to copy UNC file)" groupRelation="and">                         <!-- Copy UNC file to destination Reference: https://lolbas-project.github.io/lolbas/Binaries/Replace/ --> 
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">replace.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (certreq download)" groupRelation="and">                                                <!-- Use certreq to download a file from the web. --> 
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">certreq.exe -Post -config</ParentCommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (Download a file using wscript)" groupRelation="and">                                   <!-- Use wscript to run a local VisualBasic file to download a remote file. --> 
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">wscript.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (Nimgrab - Transfer Files)" groupRelation="and">                                        <!-- Use nimgrab.exe to download a file from the web. --> 
                         <ParentImage condition="contains">cmd.exe</ParentImage>
                         <ParentCommandLine condition="contains">nimgrab.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (iwr or Invoke Web-Request download)" groupRelation="and">                              <!-- Use 'iwr' or "Invoke-WebRequest" -URI argument to download a file from the web. Note: without -URI also works in some versions. --> 
                         <OriginalFileName condition="contains">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">iwr</CommandLine>
                     </Rule>

                     <Rule name="T1105, Ingress Tool Transfer (Arbitrary file download using the Notepad++ GUP.exe binary)" groupRelation="and">                              <!-- GUP is an open source signed binary used by Notepad++ for software updates, and can be used to download arbitrary files(.zip) from internet/github. [Reference](https://x.com/nas_bench/status/1535322182863179776?s=20) Upon execution, a sample zip file will be downloaded to C:\Temp\Sample folder --> 
                         <OriginalFileName condition="contains">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">GUP.exe</CommandLine>
                     </Rule>

                     <Rule name="T1095, Non-Application Layer Protocol (Netcat C2)" groupRelation="and">                                              <!-- Start C2 Session Using Ncat To start the listener on a Linux device, type the following:  nc -l -p <port> --> 
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">ncat.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1572, Protocol Tunneling (DNS over HTTPS Large Query Volume)" groupRelation="and">                                  <!-- An infected host sending a large volume of DoH queries to a command and control server. -->    
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Get-Random -Minimum 1 -Maximum</CommandLine>
                     </Rule>

                      <Rule name="T1572, Protocol Tunneling (DNS over HTTPS Regular Beaconing)" groupRelation="and">                                  <!-- An infected host beaconing via DoH queries to a command and control server at regular intervals over time. -->    
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">-DohServer</CommandLine>
                     </Rule>    

                     <Rule name="T1572, Protocol Tunneling (run ngrok)" groupRelation="and">                                                          <!-- Download and run ngrok. Create tunnel to chosen port. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">ngrok.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1090-001, Proxy: Internal Proxy (portproxy reg key)" groupRelation="and">                               <!-- Adds a registry key to set up a proxy on the endpoint at HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\PortProxy\v4tov4 Upon execution there will be a new proxy entry in netsh netsh interface portproxy show all. -->    
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">netsh interface portproxy</ParentCommandLine>
                     </Rule>

                     <Rule name="T1090-003, Proxy: Multi-hop Proxy (Psiphon)" groupRelation="and">                               <!-- Psiphon 3 is a circumvention tool from Psiphon Inc. that utilizes VPN, SSH and HTTP Proxy technology to provide you with uncensored access to Internet. This process will launch Psiphon 3 and establish a connection. Shortly after it will be shut down via process kill commands. More information can be found about Psiphon using the following urls http://s3.amazonaws.com/0ubz-2q11-gi9y/en.html https://psiphon.ca/faq.html . -->    
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">Psiphon.bat</ParentCommandLine>
                     </Rule>

                     <Rule name="T1090-003, Proxy: Multi-hop Proxy (Tor Proxy Usage - Windows)" groupRelation="and">                               <!-- Launch the tor proxy service, which is what is utilized in the background by the Tor Browser and other applications with add-ons in order to provide onion routing functionality. -->    
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">tor.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1219, Remote Access Software (TeamViewer Files Detected Test on Windows)" groupRelation="and">                      <!-- An adversary may attempt to trick the user into downloading teamviewer and using this to maintain access to the machine. Download of TeamViewer installer will be at the destination location when sucessfully executed. -->   
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">TeamViewer</CommandLine>
                     </Rule>

                     <Rule name="T1219, Remote Access Software (AnyDesk Files Detected Test on Windows)" groupRelation="and">                         <!-- An adversary may attempt to trick the user into downloading AnyDesk and use to establish C2. Download of AnyDesk installer will be at the destination location and ran when sucessfully executed. -->   
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">AnyDesk</CommandLine>
                     </Rule>

                     <Rule name="T1219, Remote Access Software (LogMeIn Files Detected Test on Windows)" groupRelation="or">                          <!-- An adversary may attempt to trick the user into downloading LogMeIn and use to establish C2. Download of LogMeIn installer will be at the destination location and ran when sucessfully executed. -->    
                         <CommandLine condition="contains">LogMeInIgnition</CommandLine>
                         <CommandLine condition="contains">LMIIgnition</CommandLine>
                     </Rule>

                     <Rule name="T1219, Remote Access Software (GoToAssist Files Detected Test on Windows)" groupRelation="and">                      <!-- An adversary may attempt to trick the user into downloading GoToAssist and use to establish C2. Download of GoToAssist installer will be at the destination location and ran when sucessfully executed. -->   
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">GoToAssist</CommandLine>
                     </Rule>

                     <Rule name="T1219, Remote Access Software (GoToAssist Files Detected Test on Windows)" groupRelation="and">                      <!-- An adversary may attempt to trick the user into downloading GoToAssist and use to establish C2. Download of GoToAssist installer will be at the destination location and ran when sucessfully executed. -->   
                         <OriginalFileName condition="is">Cmd.Exe</OriginalFileName>
                         <CommandLine condition="contains">GoToAssist</CommandLine>
                     </Rule>

                     <Rule name="T1219, Remote Access Software (ScreenConnect Application Download and Install on Windows)" groupRelation="and">      <!-- An adversary may attempt to trick the user into downloading ScreenConnect for use as a C2 channel. Download of ScreenConnect installer will be in the Downloads directory. Msiexec will be used to quietly insall ScreenConnect. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">ScreenConnect</ParentCommandLine>
                     </Rule>

                     <Rule name="T1219, Remote Access Software (Ammyy Admin Software Execution)" groupRelation="and">                      <!-- An adversary may attempt to trick the user into downloading Ammyy Admin Remote Desktop Software for use as a C2 channel.  Upon successful execution, Ammyy Admin will be executed. -->   
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">ammyy</CommandLine>
                     </Rule>

                     <Rule name="T1219, Remote Access Software (RemotePC Software Execution)" groupRelation="and">                         <!-- An adversary may attempt to trick the user into downloading RemotePC Software for use as a C2 channel.  Upon successful execution, RemotePC will be executed. -->   
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">RemotePC</CommandLine>
                     </Rule>    

                     <Rule name="T1219, Remote Access Software (NetSupport - RAT Execution)" groupRelation="and">                          <!-- A recent trend by threat actors, once a foothold is established, maintain long term persistence using third party remote services such as NetSupport to provide the operator with access to the network using legitimate services. -->   
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">NetSupport</CommandLine>
                     </Rule>

                     <Rule name="T1219, Remote Access Software (UltraViewer - RAT Execution)" groupRelation="and">                         <!-- A recent trend by threat actors, once a foothold is established, maintain long term persistence using third party remote services such as UltraViewer to provide the operator with access to the network using legitimate services. -->   
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">UltraViewer</CommandLine>
                     </Rule>

                     <Rule name="T1219, Remote Access Software (UltraVNC Execution)" groupRelation="and">                                  <!-- An adversary may attempt to trick the user into downloading UltraVNC for use as a C2 channel. Upon successful execution, UltraVNC will be executed. -->   
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">vncviewer</CommandLine>
                     </Rule>

                     <Rule name="T1219, Remote Access Software (MSP360 Connect Execution)" groupRelation="and">                            <!-- An adversary may attempt to trick the user into downloading MSP360 Connect for use as a C2 channel. Upon successful execution, MSP360 Connect will be executed. -->   
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">Connect.exe</CommandLine>
                     </Rule>

                     <Rule name="T1219, Remote Access Software (RustDesk Files Detected Test on Windows)" groupRelation="and">             <!-- An adversary may attempt to trick the user into downloading RustDesk and use this to maintain access to the machine.  Download of RustDesk installer will be at the destination location when successfully executed. -->   
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">rustdesk</CommandLine>
                     </Rule>

                     <Rule name="T1219, Remote Access Software (Splashtop Execution)" groupRelation="and">                                 <!-- An adversary may attempt to trick the user into downloading Splashtop for use as a C2 channel. Upon successful execution, Splashtop will be executed. -->   
                         <OriginalFileName condition="is">PowerShell.EXE</OriginalFileName>
                         <CommandLine condition="contains">strwinclt</CommandLine>
                     </Rule>

                     <Rule name="T1030, Data Transfer Size Limits (Network-Based Data Transfer in Small Chunks)" groupRelation="and">                        <!-- Transferring data over a network in small chunks to evade detection. -->
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">chunksize</ParentCommandLine>
                     </Rule>

                     <Rule name="T1041, Exfiltration Over C2 Channel (Text Based Data Exfiltration using DNS subdomains)" groupRelation="and">                     <!-- An adversary using DNS tunneling to exfiltrate data over a Command and Control (C2) channel. -->    
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains all">dnsServer;exfiltratedData</ParentCommandLine>
                     </Rule>

                     <Rule name="T1567-002, Exfiltration Over Web Service: Exfiltration to Cloud Storage (Exfiltrate data with rclone to cloud Storage - Mega (Windows))" groupRelation="and">                        <!-- rclone to exfiltrate data to a remote cloud storage instance. (Mega) See https://thedfirreport.com/2022/06/16/sans-ransomware-summit-2022-can-you-detect-this/ -->    
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">rclone.exe</ParentCommandLine>
                     </Rule>

                     <Rule name="T1567-003, Exfiltration Over Web Service: Exfiltration to Text Storage Sites (Exfiltrate data with HTTP POST to text storage sites - pastebin.com (Windows))" groupRelation="and">                        <!-- HTTP POST to exfiltrate data to a remote text storage site. (pastebin) See https://web.archive.org/web/20201107203304/https://www.echosec.net/blog/what-is-pastebin-and-why-do-hackers-love-it -->    
                         <ParentImage condition="contains">powershell.exe</ParentImage>
                         <ParentCommandLine condition="contains">https://pastebin.com</ParentCommandLine>
                     </Rule>

                     <CommandLine name="Initial Investigation" condition="contains">tasklist</CommandLine>
                     <CommandLine name="Initial Investigation" condition="contains">ver</CommandLine>
                     <CommandLine name="Initial Investigation" condition="contains">ipconfig</CommandLine>
                     <CommandLine name="Initial Investigation" condition="contains">systeminfo</CommandLine>
                     <CommandLine name="Initial Investigation" condition="contains">net time</CommandLine>
                     <CommandLine name="Initial Investigation" condition="contains">netstat</CommandLine>
                     <CommandLine name="Initial Investigation" condition="contains">whoami</CommandLine>
                     <CommandLine name="Initial Investigation" condition="contains">net start</CommandLine>
                     <CommandLine name="Initial Investigation" condition="contains">qprocess</CommandLine>
                     <CommandLine name="Initial Investigation" condition="contains">query</CommandLine>
                     <CommandLine name="Initial Investigation" condition="contains">set</CommandLine>
                     <CommandLine name="Initial Investigation" condition="contains">time</CommandLine>
                     <CommandLine name="Initial Investigation" condition="contains">fsutil</CommandLine>
                     <CommandLine name="Initial Investigation" condition="contains">nslookup</CommandLine>

                     <CommandLine name="Reconnaissance" condition="contains">dir</CommandLine>
                     <CommandLine name="Reconnaissance" condition="contains">net view</CommandLine>
                     <CommandLine name="Reconnaissance" condition="contains">ping</CommandLine>
                     <CommandLine name="Reconnaissance" condition="contains">net user</CommandLine>
                     <CommandLine name="Reconnaissance" condition="contains">type</CommandLine>
                     <CommandLine name="Reconnaissance" condition="contains">net group</CommandLine>
                     <CommandLine name="Reconnaissance" condition="contains">net config</CommandLine>
                     <CommandLine name="Reconnaissance" condition="contains">net share</CommandLine>
                     <CommandLine name="Reconnaissance" condition="contains">dsquery</CommandLine>
                     <CommandLine name="Reconnaissance" condition="contains">csvde</CommandLine>
                     <CommandLine name="Reconnaissance" condition="contains">nbstat</CommandLine>
                     <CommandLine name="Reconnaissance" condition="contains">net session</CommandLine>
                     <CommandLine name="Reconnaissance" condition="contains">nltest</CommandLine>
                     <CommandLine name="Reconnaissance" condition="contains">wevtutil</CommandLine>
 
                     <CommandLine name="Spread of Infection" condition="contains">at</CommandLine>                         <!-- at \\[remote host name or IP address] 12:00 cmd /c "C:\windows\temp\mal.exe" -->
                     <CommandLine name="Spread of Infection" condition="contains">wusa</CommandLine>
                     <CommandLine name="Spread of Infection" condition="contains">wmic</CommandLine>                       <!-- wmic /node:[IP address] /user:”[user name]” /password:”[password]” process call create “cmd /c c:\Windows\System32\net.exe user” -->
                     <CommandLine name="Spread of Infection" condition="contains">sc</CommandLine>
                     <CommandLine name="Spread of Infection" condition="contains">rundll32</CommandLine>

                  </ProcessCreate>
             </RuleGroup>
   
<!-- Data: RuleName, UtcTime, ProcessGuid, ProcessId, Image, TargetFilename, CreationUtcTime, PreviousCreationUtcTime, User -->  
<!-- EVENT ID 2 : FILE CREATION TIME CHANGED [FileCreateTime]-->

               <RuleGroup groupRelation="or">
                   <FileCreateTime onmatch="exclude">

                     <Image condition="end with">AppData\Local\Google\Chrome\Application\chrome.exe</Image>
                     <Image condition="end with">Root\VFS\ProgramFilesX86\Google\Chrome\Application\chrome.exe</Image>
                     <Image condition="image">OneDrive.exe</Image>
                     <Image condition="contains">setup</Image>
                     <Image condition="end with">slack.exe</Image>
                     <Image condition="end with">AppData\Local\Microsoft\Teams\current\Teams.exe</Image>

                  </FileCreateTime>
             </RuleGroup>   

<!-- Data: Rulename, UtcTime, ProcessGuid, ProcessId, Image, User, Protocol, Initiated, SourceIsIpv6, SourceIp, SourceHostname, SourcePort, SourcePortName, DestinationIp, DestinationHostname, DestinationPort, DestinationPortName -->
<!-- EVENT ID 3 : NETWORK CONNECTION DETECTED [NetworkConnect]-->

               <RuleGroup groupRelation="or">
                   <NetworkConnect onmatch="include">

                         <DestinationPort condition="is">80</DestinationPort>
                         <DestinationPort condition="is">443</DestinationPort>
                         <DestinationPort condition="is">8001</DestinationPort>
                         <DestinationPort condition="is">465</DestinationPort>
                         <DestinationPort condition="is">8000</DestinationPort>
                         <DestinationPort condition="is">13392</DestinationPort>
                         <DestinationPort condition="is">25</DestinationPort>
                         <DestinationPort condition="is">8443</DestinationPort>
                         <DestinationPort condition="is">21</DestinationPort>
                         <DestinationPort condition="is">587</DestinationPort>
                         <DestinationPort condition="is">8080</DestinationPort>
                         <DestinationPort condition="is">53</DestinationPort>
                         <DestinationPort condition="is">82</DestinationPort>
                         <DestinationPort condition="is">135</DestinationPort>
                         <DestinationPort condition="is">3389</DestinationPort>

                     <Rule name="Malware Back Connect Ports" groupRelation="or">
                         <DestinationPort condition="is">3369</DestinationPort>                        <!-- Netwire -->
                         <DestinationPort condition="is">8765</DestinationPort>
                         <DestinationPort condition="is">9943</DestinationPort>
                         <DestinationPort condition="is">244</DestinationPort>
                         <DestinationPort condition="is">1590</DestinationPort>
                         <DestinationPort condition="is">1990</DestinationPort>
                         <DestinationPort condition="is">4040</DestinationPort>
                         <DestinationPort condition="is">7210</DestinationPort>
                         <DestinationPort condition="is">7777</DestinationPort>
                         <DestinationPort condition="is">10101</DestinationPort>
                         <DestinationPort condition="is">12322</DestinationPort>
                         <DestinationPort condition="is">14102</DestinationPort>                        <!-- Netwire -->
                         <DestinationPort condition="is">14103</DestinationPort>                        <!-- Netwire -->
                         <DestinationPort condition="is">14154</DestinationPort>
                         <DestinationPort condition="is">543</DestinationPort>                          <!-- Outgoing to Internet -->
                         <DestinationPort condition="is">700</DestinationPort>
                         <DestinationPort condition="is">743</DestinationPort>
                         <DestinationPort condition="is">1515</DestinationPort>
                         <DestinationPort condition="is">1960</DestinationPort>
                         <DestinationPort condition="is">9000</DestinationPort>
                         <DestinationPort condition="is">65520</DestinationPort>                        <!-- Netwire -->
                         <DestinationPort condition="is">81</DestinationPort>
                         <DestinationPort condition="is">100</DestinationPort>
                         <DestinationPort condition="is">843</DestinationPort>
                         <DestinationPort condition="is">1817</DestinationPort>
                         <DestinationPort condition="is">3448</DestinationPort>
                         <DestinationPort condition="is">4433</DestinationPort>
                         <DestinationPort condition="is">4455</DestinationPort>
                         <DestinationPort condition="is">5649</DestinationPort>
                         <DestinationPort condition="is">7443</DestinationPort>
                         <DestinationPort condition="is">9997</DestinationPort>
                         <DestinationPort condition="is">12100</DestinationPort>
                         <DestinationPort condition="is">12108</DestinationPort>
                         <DestinationPort condition="is">12112</DestinationPort>
                         <DestinationPort condition="is">12124</DestinationPort>
                         <DestinationPort condition="is">12143</DestinationPort>
                         <DestinationPort condition="is">12154</DestinationPort>
                         <DestinationPort condition="is">12233</DestinationPort>
                         <DestinationPort condition="is">13029</DestinationPort>
                         <DestinationPort condition="is">13101</DestinationPort>
                         <DestinationPort condition="is">13111</DestinationPort>
                         <DestinationPort condition="is">13170</DestinationPort>
                         <DestinationPort condition="is">13332</DestinationPort>
                         <DestinationPort condition="is">13334</DestinationPort>
                         <DestinationPort condition="is">13360</DestinationPort>
                         <DestinationPort condition="is">13407</DestinationPort>
                         <DestinationPort condition="is">13411</DestinationPort>
                         <DestinationPort condition="is">13441</DestinationPort>
                         <DestinationPort condition="is">49171</DestinationPort>
                         <DestinationPort condition="is">49172</DestinationPort>
                         <DestinationPort condition="is">49173</DestinationPort>
                         <DestinationPort condition="is">49178</DestinationPort>
                         <DestinationPort condition="is">49181</DestinationPort>
                         <DestinationPort condition="is">49184</DestinationPort>
                         <DestinationPort condition="is">49184</DestinationPort>
                         <DestinationPort condition="is">448</DestinationPort>
                         <DestinationPort condition="is">473</DestinationPort>
                         <DestinationPort condition="is">666</DestinationPort>                    <!-- Many Trojans & Cain and Abel -->
                         <DestinationPort condition="is">3675</DestinationPort>
                         <DestinationPort condition="is">3939</DestinationPort>
                         <DestinationPort condition="is">5552</DestinationPort>                   <!-- Netwire -->
                         <DestinationPort condition="is">6446</DestinationPort>
                         <DestinationPort condition="is">12103</DestinationPort>
                         <DestinationPort condition="is">13145</DestinationPort>
                         <DestinationPort condition="is">13394</DestinationPort>
                         <DestinationPort condition="is">49177</DestinationPort>
                         <DestinationPort condition="is">49179</DestinationPort>
                         <DestinationPort condition="is">49182</DestinationPort>
                         <DestinationPort condition="is">777</DestinationPort>                    <!-- Netcrack & many Trojans -->
                         <DestinationPort condition="is">2443</DestinationPort>
                         <DestinationPort condition="is">5445</DestinationPort>
                         <DestinationPort condition="is">9007</DestinationPort>                   <!-- Netwire -->
                         <DestinationPort condition="is">12102</DestinationPort>
                         <DestinationPort condition="is">13504</DestinationPort>
                         <DestinationPort condition="is">13505</DestinationPort>
                         <DestinationPort condition="is">1904</DestinationPort>
                         <DestinationPort condition="is">4438</DestinationPort>
                         <DestinationPort condition="is">4444</DestinationPort>                   <!-- Metasploit -->
                         <DestinationPort condition="is">6625</DestinationPort>
                         <DestinationPort condition="is">12101</DestinationPort>
                         <DestinationPort condition="is">13507</DestinationPort>
                         <DestinationPort condition="is">49180</DestinationPort>
                         <DestinationPort condition="is">198</DestinationPort>
                         <DestinationPort condition="is">200</DestinationPort>                    <!-- Controller -->
                         <DestinationPort condition="is">1034</DestinationPort>                   <!-- Various Trojans --> 
                         <DestinationPort condition="is">3360</DestinationPort>                   <!-- Netwire --> 
                         <DestinationPort condition="is">1604</DestinationPort>                   <!-- DarkComet RAT -->
                         <DestinationPort condition="is">13506</DestinationPort>
                         <DestinationPort condition="is">65535</DestinationPort>
                         <DestinationPort condition="is">243</DestinationPort>                    <!-- Dridex -->
                         <DestinationPort condition="is">1443</DestinationPort>
                         <DestinationPort condition="is">1777</DestinationPort>                   <!-- Scarab Trojan --> 
                         <DestinationPort condition="is">8143</DestinationPort>                   <!-- Dridex -->
                         <DestinationPort condition="is">2448</DestinationPort>
                         <DestinationPort condition="is">4443</DestinationPort>
                         <DestinationPort condition="is">444</DestinationPort>                    <!-- Dridex -->
                         <DestinationPort condition="is">999</DestinationPort>
                         <DestinationPort condition="is">1143</DestinationPort>
                         <DestinationPort condition="is">1166</DestinationPort>
                         <DestinationPort condition="is">1336</DestinationPort>
                         <DestinationPort condition="is">1337</DestinationPort>
                         <DestinationPort condition="is">2013</DestinationPort>                   <!--Netwire -->
                         <DestinationPort condition="is">2201</DestinationPort>                   <!-- Jsocket Sample --> 
                         <DestinationPort condition="is">2888</DestinationPort>
                         <DestinationPort condition="is">5656</DestinationPort>                   <!-- Netwire -->
                         <DestinationPort condition="is">7447</DestinationPort>                   <!-- Dridex -->
                         <DestinationPort condition="is">8086</DestinationPort>
                         <DestinationPort condition="is">8087</DestinationPort>
                         <DestinationPort condition="is">8899</DestinationPort>
                         <DestinationPort condition="is">9050</DestinationPort>
                         <DestinationPort condition="is">9001</DestinationPort>                   <!-- TOR Network -->  
                         <DestinationPort condition="is">9898</DestinationPort>                   <!-- Many trojans and worms Jsocket Sample -->
                         <DestinationPort condition="is">9993</DestinationPort>
                         <DestinationPort condition="is">32020</DestinationPort>                  <!-- Netwire -->
                         <DestinationPort condition="is">60139</DestinationPort>
                     </Rule>     

                   </NetworkConnect>                  
             </RuleGroup>

<!-- Data UtcTime, State, Version, SchemaVersion -->
<!-- EVENT ID 4 : SYSMON SERVICE STATE CHANGED [SysmonService]-->

<!-- Data: RuleName, UtcTime, ProcessGuid, ProcessId, Image, User -->
<!-- EVENT ID 5 : PROCESS TERMINATED [ProcessTerminate]-->

               <RuleGroup groupRelation="or">
                   <ProcessTerminate onmatch="include">
                         <!--NOTE: Using "include" with no rules means nothing in this section will be logged-->
                   </ProcessTerminate>
               </RuleGroup>   

<!-- Data: RuleName, UtcTime, ImageLoaded, Hashes, Signed, Signature, SignatureStatus -->
<!-- EVENT ID 6 : DRIVER LOADED [DriverLoad]-->

               <RuleGroup groupRelation="or">
		           <DriverLoad onmatch="exclude">

                     <Signature condition="contains">microsoft</Signature> <!--Exclude signed Microsoft drivers-->
                     <Signature condition="contains">windows</Signature> <!--Exclude signed Microsoft drivers-->
                     <Signature condition="begin with">Intel </Signature> <!--Exclude signed Intel drivers-->

		           </DriverLoad>
	           </RuleGroup>

<!-- Data: RuleName, UtcTime, ProcessGuid, ProcessId, Image, ImageLoaded, FileVersion, Description, Product, Company, OriginalFileName, Hashes, Signed, Signature, SignatureStatus, User -->
<!-- EVENT ID 7 : DLL (IMAGE) LOADED [ImageLoad]-->

               <RuleGroup groupRelation="or">
                   <ImageLoad onmatch="include">
                
                     <ImageLoaded condition="begin with">c:\programdata</ImageLoaded>
                     <ImageLoaded condition="begin with">c:\user</ImageLoaded>
                     <ImageLoaded condition="is">c:\tmp</ImageLoaded>
                
                   </ImageLoad>
               </RuleGroup>


               <RuleGroup groupRelation="or">
                   <ImageLoad onmatch="exclude">

                     <SignatureStatus condition="is">Valid</SignatureStatus>

                   </ImageLoad>
               </RuleGroup>

<!-- Data: RuleName, UtcTime, SourceProcessGuid, SourceProcessId, SourceImage, TargetProcessGuid, TargetProcessId, TargetImage, NewThreadId, StartAddress, StartModule, StartFunction, SourceUser, TargetUser -->
<!-- EVENT ID 8 : REMOTE THREAD CREATED [CreateRemoteThread]-->

               <RuleGroup groupRelation="or">
                   <CreateRemoteThread onmatch="include">

                     <SourceImage condition="is">C:\Windows\system32\wbem\WmiPrvSE.exe</SourceImage>
                     <SourceImage condition="is">C:\Windows\system32\svchost.exe</SourceImage>
                     <SourceImage condition="is">C:\Windows\system32\wininit.exe</SourceImage>
                     <SourceImage condition="is">C:\Windows\system32\csrss.exe</SourceImage>
                     <SourceImage condition="is">C:\Windows\system32\services.exe</SourceImage>
                     <SourceImage condition="is">C:\Windows\system32\winlogon.exe</SourceImage>
                     <SourceImage condition="is">C:\Windows\system32\audiodg.exe</SourceImage>
                     <SourceImage condition="is">C:\Program Files (x86)\Webroot\WRSA.exe</SourceImage>
                     <StartModule condition="is">C:\Windows\system32\kernel32.dll</StartModule>
                     <TargetImage condition="end with">Google\Chrome\Application\chrome.exe</TargetImage>

                   </CreateRemoteThread>
               </RuleGroup>

<!-- Data: RuleName, UtcTime, ProcessGuid, ProcessId, Image, Device, User -->
<!-- EVENT ID 9 : RAW DISK ACCESS [RawAccessRead]-->

               <RuleGroup groupRelation="or">
                   <RawAccessRead onmatch="include">
                         <!--NOTE: Using "include" with no rules means nothing in this section will be logged-->
                   </RawAccessRead>
               </RuleGroup>

<!-- Data: RuleName, UtcTime, SourceProcessGUID, SourceProcessId, SourceThreatId, SourceImage, TargetProcessGUID, TargetProcessId, TargetImage, GrantedAccess, CallTrace, SourceUser, TargetUser -->
<!-- EVENT ID 10 : INTER-PROCESS ACCESS [ProcessAccess]-->

               <RuleGroup groupRelation="or">
                    <ProcessAccess onmatch="include">
                         <!--NOTE: Using "include" with no rules means nothing in this section will be logged-->                        
                    </ProcessAccess> 
               </RuleGroup>

<!-- Data: RuleName, UtcTime, ProcessGuid, ProcessId, Image, TargetFilename. CreationUtcTime, User -->
<!-- EVENT ID 11 : FILE CREATED [FileCreate]-->

               <RuleGroup groupRelation="or">
                   <FileCreate onmatch="include">

                     <TargetFilename condition="end with">.application</TargetFilename> 
                     <TargetFilename condition="end with">.appref-ms</TargetFilename> 
                     <TargetFilename condition="end with">.bat</TargetFilename> 
                     <TargetFilename condition="end with">.chm</TargetFilename>
                     <TargetFilename condition="end with">.cmd</TargetFilename> 
                     <TargetFilename condition="end with">.cmdline</TargetFilename> 
                     <TargetFilename condition="end with">.docm</TargetFilename> 
                     <TargetFilename condition="end with">.exe</TargetFilename> 
                     <TargetFilename condition="end with">.jar</TargetFilename> 
                     <TargetFilename condition="end with">.jnlp</TargetFilename> 
                     <TargetFilename condition="end with">.jse</TargetFilename> 
                     <TargetFilename condition="end with">.hta</TargetFilename> 
                     <TargetFilename condition="end with">.pptm</TargetFilename> 
                     <TargetFilename condition="end with">.ps1</TargetFilename> 
                     <TargetFilename condition="end with">.sys</TargetFilename> 
                     <TargetFilename condition="end with">.scr</TargetFilename> 
                     <TargetFilename condition="end with">.vbe</TargetFilename> 
                     <TargetFilename condition="end with">.vbs</TargetFilename> 
                     <TargetFilename condition="end with">.xlsm</TargetFilename> 
                     <TargetFilename condition="end with">proj</TargetFilename>
                     <TargetFilename condition="end with">.sln</TargetFilename>
                     <TargetFilename condition="end with">.xls</TargetFilename> 
                     <TargetFilename condition="end with">.ppt</TargetFilename> 
                     <TargetFilename condition="end with">.rft</TargetFilename>

                   </FileCreate>
               </RuleGroup>

<!-- Data: RuleName, EventType, UtcTime, ProcessGuid, ProcessId, Image, TargetObject, User, Details, NewName -->             
<!-- EVENT ID 12 & 13 & 14 : REGISTRY MODIFICATION [RegistryEvent]-->
         <!--EVENT 12: "Registry object added or deleted"-->
	     <!--EVENT 13: "Registry value set"-->
	     <!--EVENT 14: "Registry objected renamed"-->

               <RuleGroup groupRelation="or">
                    <RegistryEvent onmatch="include">

                         <TargetObject name="T1059-001, Command and Scripting Interpreter" condition="contains">HKCU\Software\Classes</TargetObject>
                         <TargetObject name="T1037-001, Boot or Logon Initialization Scripts: Logon Script" condition="contains">HKCU\Enviroment</TargetObject>
                         <TargetObject name="T1133, External Remote Services" condition="contains">HKLM\Software\Wow6432Node\Google\Chrome\Extensions</TargetObject>
                         <TargetObject name="T1574-011, Hijack Execution Flow: Services Registry Permissions Weakness" condition="contains">HKLM\SYSTEM\CurrentControlSet\Services</TargetObject>
                         <TargetObject name="T1574-012, Hijack Execution Flow: COR_PROFILER (User scope COR_PROFILER)" condition="contains">HKCU\Software\Classes\CLSID</TargetObject>
                         <TargetObject name="T1574-012, Hijack Execution Flow: COR_PROFILER (User scope COR_PROFILER)" condition="contains">HKCU\Environment</TargetObject>
                         <TargetObject name="T1574-012, Hijack Execution Flow: COR_PROFILER (User scope COR_PROFILER)" condition="contains">HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment</TargetObject>
                         <TargetObject name="T1078-001, valid Accounts: Default Accounts" condition="contains">HKLM\system\CurrentControlSet\Control\Terminal Server</TargetObject>
                         <TargetObject name="T1070-005, Indicator Removal on Host: Network Share Connection Removal" condition="contains">HKLM\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKLM\Software\Microsoft\Windows\CurrentVersion\Run</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap\</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKLM\SYSTEM\CurrentControlSet\Control\FileSystem</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKCU\Software\Microsoft\Windows\CurrentVersion\policies\system</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKCU\Software\Policies\Microsoft\Windows\System</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKCU\SOFTWARE\Policies\Microsoft\Windows\Explorer</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKLM\SYSTEM\CurrentControlSet\Control\SafeBoot\Minimal\</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKLM\SYSTEM\CurrentControlSet\Control\SafeBoot\Network\</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKCU\Software\AppDataLow\Software\Microsoft\</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Event Viewer</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\Winstations\RDP-Tcp</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKLM\SOFTWARE\Policies\Microsoft\Windows Defender Security Center\Notifications</TargetObject>
                         <TargetObject name="T1112, Modify registry" condition="contains">HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKLM\SOFTWARE\Classes\.wav\OpenWithProgIds</TargetObject>
                         <TargetObject name="T1112, Modify Registry" condition="contains">HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap\ProtocolDefaults</TargetObject> 

                  </RegistryEvent>
             </RuleGroup>


             <RuleGroup groupRelation="or">
                 <RegistryEvent onmatch="exclude">

                     <Image condition="begin with">:\ProgramData\Microsoft\Windows Defender\Platform</Image>

                 </RegistryEvent>
             </RuleGroup>

<!-- Data: RuleName, UtcTime, ProcessGuid, ProcessId, Image, TargetFilename, CreationUtcTime, Hash, Contents, User -->
<!-- EVENT ID 15 : ALTERNATE DATA STREAM CREATED [FileCreateStreamHash]-->

               <RuleGroup groupRelation="or">
                   <FileCreateStreamHash onmatch="include">
                         <!--NOTE: Using "include" with no rules means nothing in this section will be logged-->
                   </FileCreateStreamHash> 
               </RuleGroup>

<!-- Data: UtcTime, Configuration, ConfigurationFileHash -->
<!-- EVENT ID 16 : SYSMON CONFIGURATION CHANGE--> 

<!-- Data: RuleName, EventType, UtcTime, ProcessGuid, ProcessId, PipeName, Image, User -->
<!-- EVENT ID 17 & 18 : PIPE CREATED / PIPE CONNECTED [PipeEvent]-->
         <!--EVENT 17: "Pipe Created"-->
	     <!--EVENT 18: "Pipe Connected"-->

               <RuleGroup name="" groupRelation="or">
			     <PipeEvent onmatch="include">
				
				    <PipeName condition="contains any">paexec;remcom;csexec</PipeName>                           <!-- Remote Command Execution Tools -->
				    <PipeName condition="contains any">\lsadump;\cachedump;\wceservicepipe</PipeName>            <!-- Password or Credential Dumpers -->
				<!-- Malware -->
				    <PipeName condition="contains any">\isapi_http;\isapi_dg;\isapi_dg2;\sdlrpc;\ahexec;\winsession;\lsassw;\46a676ab7f179e511e30dd2dc41bd388;\9f81f59bc58452127884ce513865ed20;\e710f28d59aa529d6792ca6ff0ca1b34;\rpchlp_3;\NamePipe_MoreWindows;\pcheap_reuse;\gruntsvc;\583da945-62af-10e8-4902-a8f205c72b2e;\bizkaz;\svcctl;\Posh;\jaccdpqnvbrrxlaf;\csexecsvc</PipeName>
				    <PipeName condition="contains any">\atctl;\userpipe;\iehelper;\sdlrpc;\comnap</PipeName>
				<!-- Cobalt Strike Pipe Names -->
                    <PipeName condition="contains all">MSSE-;-server</PipeName>
                    <PipeName condition="begin with">\postex_</PipeName>
                    <PipeName condition="begin with">\postex_ssh_</PipeName>
                    <PipeName condition="begin with">\status_</PipeName>
                    <PipeName condition="begin with">\msagent_</PipeName>
			     </PipeEvent>
		       </RuleGroup>

<!-- Data: RuleName, EventType, UtcTime, Operation, User, EventNamespace, Name, Query, Type, Destination, Consumer, Filter -->
<!-- EVENT ID 19 & 20 & 21 : WMI EVENT MONITORING [WmiEvent]-->
         <!--EVENT 19: "WmiEventFilter activity detected"-->
	     <!--EVENT 20: "WmiEventConsumer activity detected"-->
	     <!--EVENT 21: "WmiEventConsumerToFilter activity detected"-->

               <RuleGroup groupRelation="or">
                   <WmiEvent onmatch="include">

                     <Operation condition="is">Created</Operation>

                   </WmiEvent>
               </RuleGroup>

<!-- Data: RuleName, UtcTime, ProcessGuid, ProcessId, QueryName, QueryResults, Image, User -->
<!-- EVENT ID 22 : DNS QUERY [DnsQuery]-->

               <RuleGroup groupRelation="or">
                   <DnsQuery onmatch="include">
                         <!--NOTE: Using "include" with no rules means nothing in this section will be logged-->
                   </DnsQuery>
               </RuleGroup>

<!-- Data: RuleName, UtcTime, ProcessGuid, ProcessId, User, Image, TargetFilename, Hashes, IsExecutable, Archived -->
<!-- EVENT ID 23 : FILE DELETE [FileDelete]-->

               <RuleGroup groupRelation="or">
                   <FileDelete onmatch="include">

                         <Rule groupRelation="and">
                             <TargetFilename condition="contains">\Downloads\</TargetFilename>
                             <TargetFilename condition="contains any">.com;.bat;.exe;.reg;.ps1;.vbs;.vba;.lnk;.doc;.xls;.hta;.bin;.7z;.dll;.xla;.cmd;.sh;.lnk;.pptm;.scr;.msi;.sct</TargetFilename>
                         </Rule>

                         <Rule groupRelation="and">
                             <TargetFilename condition="contains">\Appdata\Local\Temp\</TargetFilename>
                             <TargetFilename condition="contains any">.com;.bat;.exe;.reg;.ps1;.vbs;.vba;.lnk;.doc;.xls;.hta;.bin;.7z;.dll;.xla;.cmd;.sh;.lnk;.pptm;.scr;.msi;.sct</TargetFilename>
                         </Rule>

                         <Rule groupRelation="and">
                             <TargetFilename condition="contains">Appdata\</TargetFilename>
                             <TargetFilename condition="contains any">.com;.bat;.exe;.reg;.ps1;.vbs;.vba;.lnk;.doc;.xls;.hta;.bin;.7z;.dll;.xla;.cmd;.sh;.lnk;.pptm;.scr;.msi;.sct</TargetFilename>
                         </Rule>

                         <Rule groupRelation="and">
                             <TargetFilename condition="begin with">C:\Windows\Temp</TargetFilename>
                             <TargetFilename condition="contains any">.com;.bat;.exe;.reg;.ps1;.vbs;.vba;.lnk;.doc;.xls;.hta;.bin;.7z;.dll;.xla;.cmd;.sh;.lnk;.pptm;.scr;.msi;.sct</TargetFilename>
                         </Rule>

                         <Rule groupRelation="and">
                             <TargetFilename condition="begin with">C:\Windows\SysWOW64</TargetFilename>
                             <TargetFilename condition="contains any">.com;.bat;.exe;.reg;.ps1;.vbs;.vba;.lnk;.doc;.xls;.hta;.bin;.7z;.dll;.xla;.cmd;.sh;.lnk;.pptm;.scr;.msi;.sct</TargetFilename>
                         </Rule>

                         <Rule groupRelation="and">
                             <TargetFilename condition="begin with">C:\Windows\Tasks</TargetFilename>
                             <TargetFilename condition="contains any">.com;.bat;.exe;.reg;.ps1;.vbs;.vba;.lnk;.doc;.xls;.hta;.bin;.7z;.dll;.xla;.cmd;.sh;.lnk;.pptm;.scr;.msi;.sct</TargetFilename>
                         </Rule>

                         <Rule name="Office documents" groupRelation="or">
                             <TargetFilename condition="end with">.doc</TargetFilename>
                             <TargetFilename condition="end with">.dot</TargetFilename>
                             <TargetFilename condition="end with">.docx</TargetFilename>
                             <TargetFilename condition="end with">.docm</TargetFilename>
                             <TargetFilename condition="end with">.doc</TargetFilename>
                             <TargetFilename condition="end with">.dot</TargetFilename>
                             <TargetFilename condition="end with">.docx</TargetFilename>
                             <TargetFilename condition="end with">.docm</TargetFilename>
                             <TargetFilename condition="end with">.dotx</TargetFilename>
                             <TargetFilename condition="end with">.dotm</TargetFilename>
                             <TargetFilename condition="end with">.docb</TargetFilename>
                             <TargetFilename condition="end with">.xls</TargetFilename>
                             <TargetFilename condition="end with">.xlt</TargetFilename>
                             <TargetFilename condition="end with">.xlm</TargetFilename>
                             <TargetFilename condition="end with">.xlsx</TargetFilename>
                             <TargetFilename condition="end with">.xlsm</TargetFilename>
                             <TargetFilename condition="end with">.xltx</TargetFilename>
                             <TargetFilename condition="end with">.xltm</TargetFilename>
                             <TargetFilename condition="end with">.xlsb</TargetFilename>
                             <TargetFilename condition="end with">.ppt</TargetFilename>
                             <TargetFilename condition="end with">.pptx</TargetFilename>
                             <TargetFilename condition="end with">.pptm</TargetFilename>
                             <TargetFilename condition="end with">.potx</TargetFilename>
                             <TargetFilename condition="end with">.potm</TargetFilename>
                             <TargetFilename condition="end with">.odt</TargetFilename>
                             <TargetFilename condition="end with">.ods</TargetFilename>
                             <TargetFilename condition="end with">.odp</TargetFilename>
                             <TargetFilename condition="end with">.pdf</TargetFilename>
                             <TargetFilename condition="end with">.rtf</TargetFilename>
                         </Rule>

                         <Rule name="Scripts and Payloads" groupRelation="or">
                             <TargetFilename condition="end with">.aspx</TargetFilename>
                             <TargetFilename condition="end with">.bat</TargetFilename>
                             <TargetFilename condition="end with">.ps1</TargetFilename>
                             <TargetFilename condition="end with">.vbs</TargetFilename>
                             <TargetFilename condition="end with">.vba</TargetFilename>
                             <TargetFilename condition="end with">.hta</TargetFilename>
                             <TargetFilename condition="end with">.jar</TargetFilename>
                             <TargetFilename condition="end with">.js</TargetFilename>
                             <TargetFilename condition="end with">.cmd</TargetFilename>
                             <TargetFilename condition="end with">.sh</TargetFilename>
                             <TargetFilename condition="end with">.sct</TargetFilename>
                             <TargetFilename condition="end with">.lnk</TargetFilename>
                         </Rule>

                         <Rule name="Other Files" groupRelation="or">
                             <TargetFilename condition="end with">.bin</TargetFilename>
                             <TargetFilename condition="end with">.iso</TargetFilename>
                             <TargetFilename condition="end with">.7z</TargetFilename>
                             <TargetFilename condition="end with">.msi</TargetFilename>
                             <TargetFilename condition="end with">.dmp</TargetFilename>
                             <TargetFilename condition="end with">.reg</TargetFilename>
                         </Rule>

                   </FileDelete>
              </RuleGroup>

<!-- Data: RuleName, UtcTime, ProcessGuid, ProcessId, Image, Session, ClientInfo, Hashes, Archived, User -->
<!-- EVENT ID 24 : CLIPBOARD CHANGE [ClipboardChange]-->

               <RuleGroup groupRelation="or">
                   <ClipboardChange onmatch="include">
                         <!--NOTE: Using "include" with no rules means nothing in this section will be logged-->
                   </ClipboardChange>
               </RuleGroup>

<!-- RuleName, UtcTime, ProcessGuid, ProcessId, Image, Type, User -->
<!-- EVENT ID 25 : PROCESS TAMPERING [ProcessTampering]-->

               <RuleGroup groupRelation="or">
                    <ProcessTampering onmatch="exclude">
                    
                    </ProcessTampering>
               </RuleGroup> 

<!-- Data: RuleName, UtcTime, ProcessGuid, ProcessId, User, Image, TargetFilename, Hashes, IsExecutable -->
<!-- EVENT ID 26 : FILE DELETE AND OVERWRITE [FileDeleteDetected]-->

               <RuleGroup groupRelation="or">
                   <FileDeleteDetected onmatch="include"> 
                         <!--NOTE: Using "include" with no rules means nothing in this section will be logged-->                
                   </FileDeleteDetected>
               </RuleGroup> 

<!-- Data: RuleName, UtcTime, ProcessGuid, ProcessId, User, Image, TargetFilename, Hashes -->
<!-- EVENT ID 27 : FILE BLOCK EXECUTABLE AND OVERWRITE [FileBlockExecutable]-->

               <RuleGroup groupRelation="or">
                   <FileBlockExecutable onmatch="include">
                         <!--NOTE: Using "include" with no rules means nothing in this section will be logged-->
                   </FileBlockExecutable>
               </RuleGroup>

<!-- Data: RuleName, UtcTime, ProcessGuid, ProcessId, User, Image, TargetFilename, Hashes, IsExecutable -->
<!-- EVENT ID 28 : FILEBLOCK SHREDDING [FileBlockShredding]-->

               <RuleGroup groupRelation="or">
                   <FileBlockShredding onmatch="include">
                        <!--NOTE: Using "include" with no rules means nothing in this section will be logged-->
                   </FileBlockShredding> 
               </RuleGroup>

<!-- Data: RuleName, UtcTime, ProcessGuid, ProcessId, User, Image, TargetFilename, Hashes -->
<!-- EVENT ID 29 : FILE EXECUTABLE DETECTED : [FileExecutableDetected]-->

               <RuleGroup groupRelation="or">
                   <FileExecutableDetected onmatch="include">

                         <TargetFilename condition="begin with">C:\ProgramData\</TargetFilename>
                         <TargetFilename condition="begin with">C:\Users\</TargetFilename>

                   </FileExecutableDetected>               
               </RuleGroup>


               <RuleGroup groupRelation="or">
                    <FileExecutableDetected onmatch="exclude">

                         <Image condition="is">C:\WINDOWS\system32\cleanmgr.exe</Image>
                         <Image condition="begin with">C:\ProgramData\Microsoft\Windows Defender</Image>

                    </FileExecutableDetected>
               </RuleGroup>    
                          

    </EventFiltering>
</Sysmon>                     